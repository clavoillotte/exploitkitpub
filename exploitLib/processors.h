#pragma once


#include "exploitLib.h"

namespace text_processing
{
   class normalizer
   {
      normalizer() {}

      bool no_space_after(wchar_t c)
      {
         switch (c)
         {
         case L'(':
            return true;
         case L',':
            return true;
         case L'+':
            return true;
         default:
            return false;
         }
      }

      auto& normalise_blanks(x::unistr& line)
      {
         unsigned int pos = 0;
         bool space_done = false;
         wchar_t last = L'\x0000';

         for (auto& c : line)
         {
            switch (c)
            {
            case L'\x20':
            case L'\x07':
            case L'\x09':
            case L'\r':
               if (!space_done && !no_space_after(last))
               {
                  line[pos++] = L' ';
                  space_done = true;
               }
               break;
            default:
               line[pos++] = c;
               space_done = false;
               last = c;
            }

         }
         line.resize(pos);
         return line;
      }
   public:
      auto operator()(x::unistr& line)
      {
         normalise_blanks(line);

         if (line.ends_with(L'\r'))line.resize(line.length() - 1);

         if (line.length() <= 2) return false;
         return true;
      }

      static normalizer& getInstance()
      {
         static normalizer instance{};
         return instance;
      }
   };
}
static auto& normalizer = text_processing::normalizer::getInstance();

namespace text_processing
{
   class replacer {

      std::map < std::wstring, std::wstring  > newReplacements;

      static const inline std::map < std::wstring, std::wstring  > replacements
      {
         #include "replacements.h"
      };

      replacer() {};

      void addReplacement(std::wstring& key, std::wstring& val) {
         if (replacements.find(key) == replacements.end())
         {
            std::wcout << L"adding replacement:" << key << L"=" << val << std::endl;
            newReplacements.emplace(key, val);

         }
      }
   public:
      friend  std::wostream& operator << (std::wostream& out, const replacer& me)
      {
         std::wstring asText;
         int lc = 0;
         for (auto& r : me.newReplacements) {
            asText = asText + L"{L\"" + r.first + L"\", L\"" + r.second + L"\"},";
            if (++lc % 5 == 0) {
               out << asText << std::endl;
               asText = L"";
            }

         }
         return (out << asText);
      }

      static replacer& getInstance()
      {
         static replacer instance{};
         return instance;
      }

      auto operator()(x::unistr& line, bool learn = false)
      {
         if (!learn)
         {
            for (auto& r : replacements) {
               line.findAndReplaceAll(r.first, r.second);
            }
         }
         if (!learn) return true;

         if (std::count(line.begin(), line.end(), L'(') != 0) return false;
         if (std::count(line.begin(), line.end(), L')') != 0) return false;
         if (std::count(line.begin(), line.end(), L' ') != 1) return false;

         auto keyval = line.split(L" "s);
         auto key = keyval.at(0);
         auto val = keyval.at(1);

         if (key.at(0) >= L'0' && key.at(0) <= L'9') return false;
         if (std::count(val.begin(), val.end(), L'\"') % 2 != 0) return false;

         if (key.find(L"\"") != std::wstring::npos) return false;

         if (key.length() <= 2 || val.length() <= 2)
         {
            return false;
         }

         if (key == val) return false;

         if (val.find(L"\"") != std::wstring::npos) val = val.findAndReplaceAll(L"\""s, L"\\\"");

         if (x::unistr{ key }.starts_with(L"0x"s)) return false;

         addReplacement(key, val);

         return true;
      }

   };
}
static auto& replacer = text_processing::replacer::getInstance();


namespace text_processing
{
   class line_buffer {

      line_buffer() {};
   public:
      static line_buffer& getInstance()
      {
         static line_buffer instance{};
         return instance;
      }

      auto operator()(x::unistr& line)
      {

         static x::unistr buf{};

         if (line.ends_with(L'\\'))
         {
            buf = buf + line.substr(0, line.length() - 1);
            return false;
         }
         else
         {
            if (!buf.empty()) {
               auto filefromend = line.find(L"-");
               if (filefromend == std::wstring::npos)
               {
                  filefromend = 0;
               }
               else
               {
                  filefromend++;
               }
               buf = buf + line.substr(filefromend);
               line = buf;
               buf = L"";
            }
            return true;
         }

         return true;
      }

   };
}
static auto& buffer = text_processing::line_buffer::getInstance();


namespace text_processing
{
   class bracket_splitter {

      bracket_splitter() {};
   public:

      using bracket_pre = std::wstring;
      using bracket_content = std::wstring;
      using bracket_info = std::pair<bracket_pre, bracket_content>;

      auto operator()(x::unistr& line)
      {
         std::vector< bracket_info > brackets_parsed;

         bracket_pre pre;

         unsigned int bracket_nestness = 0;
         std::wstring buf;
         for (auto& c : line)
         {
            switch (c)
            {
            case L' ':
               buf = L"";
               break;
            case L'(':
               bracket_nestness++;
               buf = buf + c;
               if (bracket_nestness == 1)
               {
                  pre = buf.substr(0, buf.length() - 1);
                  buf = L"";
               }
               break;
            case L')':
               bracket_nestness--;
               buf = buf + c;
               if (bracket_nestness == 0)
               {
                  brackets_parsed.emplace_back(std::make_pair(pre, buf.substr(0, buf.length() - 1)));
                  buf = L"";
                  pre = L"";
               }
               break;
            default:
               buf = buf + c;
            }
         }

         return brackets_parsed;
      }
      static bracket_splitter& getInstance()
      {
         static bracket_splitter instance{};
         return instance;
      }
   };
}
static auto& brackets = text_processing::bracket_splitter::getInstance();