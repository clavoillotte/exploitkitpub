#pragma once


#include "exploitLib.h"
#include <frozen/unordered_map.h>
 namespace text_processing
{
 
   class normalizer
   {
      normalizer() {}

      bool no_space_after(wchar_t c)
      {
         switch (c)
         {
         case L'(':
            return true;
         case L',':
            return true;
         case L'+':
            return true;
         default:
            return false;
         }
      }

      auto& normalise_blanks(x::unistr& line)
      {
         unsigned int pos = 0;
         bool space_done = false;
         wchar_t last = L'\x0000';
         int indent = 0;
         for (auto& c : line)
         {
            switch (c)
            {
            case L'(':
               line[pos++] = c;
               indent++;
               break;
            case L')':
               line[pos++] = c;
               indent--;
               break;
            case L'\x20':
            case L'\x07':
            case L'\x09':
            case L'\r':
               if (indent == 0 && !space_done && !no_space_after(last))
               {
                  line[pos++] = L' ';
                  space_done = true;
               }
               break;
            default:
               line[pos++] = c;
               space_done = false;
               last = c;
            }

         }
         line.resize(pos);
         return line;
      }
   public:
      auto operator()(x::unistr& line)
      {
         normalise_blanks(line);
          return true;
      }

      static normalizer& getInstance() { static normalizer instance{}; return instance; }
   };
}
static auto& normalizer = text_processing::normalizer::getInstance();

namespace text_processing
{
   class replacer {

 
      std::map<std::wstring, std::wstring> replacements{
#include "replacements.h"                         
      };         

      std::map < std::wstring, std::wstring  > lineReplacements;
 
      
      replacer() {};
      void addLineReplacement(std::wstring& key, std::wstring& val)
      {
         lineReplacements.emplace(key, val);
      }

      void addReplacement(std::wstring& key, std::wstring& val) 
      {
         replacements.emplace(key, val);
       }
   public: 
      friend  std::wostream& operator << (std::wostream& out, const replacer& me)
      {
         std::wstring asText;
         int lc = 0;
         for (auto& r : me.replacements)
         {
            if(r.first.find(L"DEVICE") != std::wstring::npos || r.first.find(L"BASE") != std::wstring::npos)
            {
               asText = asText + L"{R\"(" + r.first + L")\", R\"(" + r.second + L")\"},";
               if (++lc % 4 == 0) {
                  out << asText << std::endl;
                  asText = L"";
               }
            }
            
         } 
         for (auto& r : me.lineReplacements) {
               out << L"{L\"" + r.first + L"\", L\"" + r.second + L"\"}," << std::endl;
          }
         return (out << asText);
      } 

      auto linerepl(x::unistr& line)
      {
         unistr org = line;
           unistr tmp = L"";
         while (tmp != line)
         {
    
            tmp = line;
            for (auto& r : lineReplacements)
            {
               line.findAndReplaceAll( r.first.data(),  r.second.data());
            }
         }
      }
      auto operator()( x::unistr& line )
      {
         unistr tmp=L"";
         while(tmp != line)
          {
            tmp = line;
            for (auto& r : replacements)
            {
               auto find = r.first ;
               auto replace = r.second  ;
               if (find == line)
               {
                  //std::wcerr << L"Replacing:" << find << L" with: " << replace << std::endl;
                  line = replace;
               }
            }
         }
      }
      auto learn(x::unistr key, x::unistr val)
      {
         if (key.at(0) >= L'0' && key.at(0) <= L'9') return false;
         if (std::count(val.begin(), val.end(), L'\"') % 2 != 0) return false;

         if (key.find(L"\"") != std::wstring::npos) return false;

         if (key.length() <= 2 || val.length() <= 2)  { return false;  }

         if (key == val) return false;
 
         if ( key.starts_with(L"0x"s) ) return false;

         if (val.find(key) != std::wstring::npos) return false;
         if (key.find(L"iobuf") != std::wstring::npos) return false;
         if (val.find(L"iobuf") != std::wstring::npos) return false;
         if (key.find(L"STOR") != std::wstring::npos) return false;
         if (key.find(L"BASE") != std::wstring::npos) return false;
         addReplacement(key, val);

         return true;
      }
      auto learnLine(x::unistr key, x::unistr val)
      {
         if (key.find(L"CTL_CODE(") != std::wstring::npos) return false;
         if (key.find(L"iobuf") != std::wstring::npos) return false;
         if (val.find(L"iobuf") != std::wstring::npos) return false;
         if (key.find(L"CE_MODE") != std::wstring::npos) return false;
         if (key.find(L"IAL") != std::wstring::npos) return false;
         if (key.find(L"ICE") != std::wstring::npos) return false;

         addLineReplacement(key, val);

         return true;
      }
      static replacer& getInstance() { static replacer instance{}; return instance; }
   };
}
static auto& replacer = text_processing::replacer::getInstance();


namespace text_processing
{
   class line_buffer
   {
      line_buffer() {};
   public:
      auto operator()(x::unistr& line)
      {
         static x::unistr buf{};

         if (line.ends_with(L'\\')){
            buf = buf + line.substr(0, line.length() - 1);
            return false;
         } else {
            buf = buf + line ;
            line = buf;
            buf = L"";
            
            return true;
         }
         return true;
      }
      static line_buffer& getInstance(){ static line_buffer instance{}; return instance; }
   };
}
static auto& buffer = text_processing::line_buffer::getInstance();


namespace text_processing
{

   struct parts : std::deque< x::unistr > {
      using deque::emplace_back;
      auto pop() {
         if (size() == 0) return ""_u;
         auto ret = at(0);
         pop_front();
         return ret;
      }
   };
   class bracket_splitter 
   {
      bracket_splitter() {};
   public:
 
      auto operator()(x::unistr& line)
      {
         x::unistr key;
         x::unistr val;

         unsigned int bracket_nestness = 0;
         std::wstring buf;
         int a = 4;
         for (auto& c : line)
         {
            switch (c)
            {
            case L'\r':
            case L'\n':
            case L'\t':
            case L' ':
               if ((buf.size() > 0) && bracket_nestness == 0)
               {
                  if (key.size() == 0)
                  {
                     key = buf;
                     buf = L"";
                  }
               }
               break;
            case L'(':
               bracket_nestness++;
               buf = buf + c;
               break;
            case L')':
               bracket_nestness--;
               buf = buf + c;
               break;
            default:
               buf = buf + c;
            }
         }
         val = buf;

         return std::make_pair(key,val );
      }
      static bracket_splitter& getInstance(){ static bracket_splitter instance{}; return instance; }
   };
}
static auto& brackets = text_processing::bracket_splitter::getInstance();