#pragma once

#include "../../pch.h"   
#include <wil\result_macros.h> 
#include "ntdll.h"

typedef struct _SECURITY_QUALITY_OF_SERVICE {
    DWORD                          Length;
    SECURITY_IMPERSONATION_LEVEL   ImpersonationLevel;
    SECURITY_CONTEXT_TRACKING_MODE ContextTrackingMode;
    BOOLEAN                        EffectiveOnly;
} SECURITY_QUALITY_OF_SERVICE, * PSECURITY_QUALITY_OF_SERVICE;

std::wstring formatErrorCode( DWORD errorCode )
{
   HMODULE hNtDll = LoadLibrary( L"NTDLL.DLL" );

   LPVOID lpMessageBuffer = NULL; 
   if (hNtDll == NULL) return  L"Error";

   FormatMessage( 
      FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_FROM_HMODULE,
      hNtDll,
      RtlNtStatusToDosError(errorCode),
      MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
      (LPWSTR)& lpMessageBuffer,
      0,
      NULL
   );

   FreeLibrary(hNtDll);
   std::wstring errMsg {  (lpMessageBuffer == nullptr ?  L"" : ((wchar_t*) lpMessageBuffer)) };

   return errMsg ;
}  

struct objattr
{
   HANDLE RootDirectory = nullptr;
   unistr ObjectName;
   ULONG Attributes = NULL;
   PVOID SecurityDescriptor = nullptr;        
   PVOID SecurityQualityOfService = nullptr;    

   OBJECT_ATTRIBUTES    inner {
      sizeof( OBJECT_ATTRIBUTES ), 
      RootDirectory,
      ObjectName.asUNICODE_STRING(), 
      Attributes,
      SecurityDescriptor, 
      SecurityQualityOfService 
   };
   public:
 
   operator OBJECT_ATTRIBUTES& (){ 
      return inner ; }

   objattr( 
      unistr name ,
      ::HANDLE rootdir = nullptr,
      ULONG attributes = 0,
      PVOID securityDescriptor = NULL, 
      PVOID securityQualityOfService = NULL
   ) : 
      ObjectName(   name   ),
      RootDirectory( rootdir ), 
      Attributes( attributes ),
      SecurityDescriptor( securityDescriptor ),
      SecurityQualityOfService( securityQualityOfService )
   {}
 
   objattr(
      ::HANDLE rootdir ,
       ULONG attributes = 0,
      PVOID securityDescriptor = NULL,
      PVOID securityQualityOfService = NULL
   ) :
      ObjectName(  unistr{ L"" } ),
      RootDirectory(rootdir),
      Attributes(attributes),
      SecurityDescriptor(securityDescriptor),
      SecurityQualityOfService(securityQualityOfService)
   {}
     objattr( 
      ::HANDLE rootdir ,
      unistr name ,
      ULONG attributes = 0,
      PVOID securityDescriptor = NULL, 
      PVOID securityQualityOfService = NULL
   ) : 
        ObjectName(    name  ),
      RootDirectory( rootdir ), 
      Attributes( attributes ),
      SecurityDescriptor( securityDescriptor ),
      SecurityQualityOfService( securityQualityOfService )
   {}
   objattr( 
      unistr name ,
      ULONG attributes ,
      PVOID securityDescriptor  , 
      PVOID securityQualityOfService  
   ) : 
      ObjectName( name  ),
      Attributes( attributes ),
      SecurityDescriptor( securityDescriptor ),
      SecurityQualityOfService( securityQualityOfService )
   {}

   objattr( 
      unistr name ,
      ::HANDLE rootdir ,
      PVOID securityDescriptor  , 
      PVOID securityQualityOfService 
   ) : 
      ObjectName( name  ),
      RootDirectory( rootdir ), 
      SecurityDescriptor( securityDescriptor ),
      SecurityQualityOfService( securityQualityOfService )
   {}  

   objattr( 
      unistr name ,
      PVOID securityDescriptor  , 
      PVOID securityQualityOfService 
   ) : 
      ObjectName( name  ),
      SecurityDescriptor( securityDescriptor ),
      SecurityQualityOfService( securityQualityOfService )
   {}
};

class handle 
{
private:
   ::HANDLE privHandle;

   static ::HANDLE dupeHandleFrom( ::HANDLE handle_source )   {
      ::HANDLE tmpHandle { nullptr };

      THROW_IF_WIN32_BOOL_FALSE(
         DuplicateHandle( GetCurrentProcess(), handle_source, GetCurrentProcess(), &tmpHandle, 0, FALSE, DUPLICATE_SAME_ACCESS ) 
      );
      return tmpHandle;
   }
   handle( ::HANDLE h ) : privHandle { h } {}

public: 
   handle( const handle& other ) : privHandle { dupeHandleFrom( other.privHandle ) } {}
   handle( const nullptr_t  ) : privHandle { nullptr } {}

   handle& operator= ( const handle& other ){
      if( this != &other ) {
         privHandle = other.privHandle;
      }
      return *this;
   }
   handle( handle&& other ) noexcept  {
      if( this != &other ) {
         privHandle       = other.privHandle;
         other.privHandle = nullptr;
      }
   }
   ~handle() {
      if( privHandle != nullptr && privHandle != INVALID_HANDLE_VALUE ) CloseHandle( privHandle );
   }
   
   template< auto F, typename ...Ts >
   static handle make( ACCESS_MASK mask, OBJECT_ATTRIBUTES& oa, Ts... ts ) {
      ::HANDLE h{};
      auto status = F( &h, mask, &oa, std::forward<Ts> (ts)... );
      THROW_IF_NTSTATUS_FAILED_MSG(status, "%ws %x", oa.ObjectName->Buffer,status);
      return handle(h);
   }
   static handle make( HANDLE h ) {
      THROW_LAST_ERROR_IF(h == INVALID_HANDLE_VALUE);
      HANDLE hCopy = dupeHandleFrom(h);
     
      return handle(hCopy);
   }
   operator const ::HANDLE&() const { return privHandle; }
   ::HANDLE getHandleDupe() const { return dupeHandleFrom(privHandle); };
};  
 
template< typename OBJTYPE, auto CREATION_FUNCTION >
class NTObj {
private :
   std::wstring typeStr{ misc::cleantype::template nameOfType< OBJTYPE >() };

protected: 
   NT::handle wrappedHandle;
public:
   std::wstring objectTypeAndName { L"Unknown" };

   template< typename T,  typename ...Ts >
   NTObj( ACCESS_MASK mask,T objAttr, Ts... ts ) :
      wrappedHandle{ handle::make< CREATION_FUNCTION >( mask,objattr{  objAttr }, std::forward<Ts>(ts)... ) } 
   {
     // std::wcout << typeStr << L" " << getNTPath() <<  L" opened"s << std::endl;
   }
   template<   typename ...Ts >
   NTObj(ACCESS_MASK mask, objattr&  objAttr , Ts... ts) :
      wrappedHandle{ handle::make< CREATION_FUNCTION >(mask,  objattr{objAttr} , std::forward<Ts>(ts)...) }
   {
     // std::wcout << typeStr << L" " << ( * static_cast<OBJTYPE*>(this) )<< L" opened"s << std::endl;
   }
 
   auto getHandle() const { return wrappedHandle; };     
   auto getHandle()       { return wrappedHandle; };
 
   operator HANDLE() const {
      return wrappedHandle;
   }
   operator HANDLE()   {
      return wrappedHandle;
   }

   void makeTemp()
   {
     THROW_NTSTATUS( NtMakeTemporaryObject(wrappedHandle) );
   }
   ntpath getNTPath() const
   {
      BYTE  u8_Buffer[2000];
      DWORD u32_ReqLength = 0;

      UNICODE_STRING* pk_Info = &((OBJECT_NAME_INFORMATION*)u8_Buffer)->Name;
      pk_Info->Buffer = 0;
      pk_Info->Length = 0;

      NtQueryObject( wrappedHandle, ObjectNameInformation, u8_Buffer, sizeof(u8_Buffer), &u32_ReqLength );

      THROW_HR_IF( E_OUTOFMEMORY , pk_Info->Buffer == 0 );
      THROW_HR_IF( E_OUTOFMEMORY , pk_Info->Length == 0 );
 
      pk_Info->Buffer[ pk_Info->Length / 2 ] = 0; 
      return { pk_Info->Buffer };
   } 

   operator strpath() { return  getNTPath()  ; }
   operator const strpath() const { return   getNTPath()  ; }


   std::wostream& operator<<(std::wostream& os) const
   {
      return(os << getNTPath().substr(4));
   }
};
   

