#pragma once

#include "../../pch.h"  
#include "ntcore.h"
#include <wil\result_macros.h>  
#include "exploitLib.h"
#include "str.h" 
#include "ntdll.h"
#include "macros.h"
#include "misc.h" 
#define STATUS_BUFFER_TOO_SMALL 0xC0000023
#define STATUS_MORE_ENTRIES 0x00000105

using namespace literalNS;

namespace wnf
{
   struct statedata : std::vector< byte > {
      using std::vector< byte >::vector;

      std::wstring str(int columns = 10) {
         std::wstringstream result;
         std::wstringstream asciiBuf;
         int i = 0;
         for (auto c : *this)
         {
            i++;

            unsigned int currByte = static_cast<unsigned int>(c);
            result << std::hex << std::uppercase << std::setw(2) << std::setfill(L'0') << currByte;
            if ((currByte >= 0x21) && (currByte <= 0x7e)) {
               asciiBuf << unistr{ std::string{ (char)currByte } };
            }
            else {
               asciiBuf << L'.';
            }
            if (((i % 4) == 0)) { result << L" "; }
            if (((i % (columns * 4)) == 0)) {
               result << asciiBuf.str() << std::endl;
               asciiBuf.str(L"");
            }
         }
         while (!(i % (columns * 4)) == 0)
         {
            if (((i % 4) == 0)) { result << L" "; }
            result << "  ";
            i++;
         }
         result << L" " << asciiBuf.str() << std::endl;

         return result.str();
      }
   };

   struct wnfState 
   {
      misc::wnf::WNF_STATE_NAME name;

      wnfState( misc::wnf::WNF_STATE_NAME name ) :
         name{ name } {}

      wnfState( std::wstring name ) :
         name{ strToStateName( name ) } {}
 
      void setStateData(statedata statedata) {
         THROW_IF_NTSTATUS_FAILED(
            misc::wnf::NtUpdateWnfStateData(
               &name,
              &statedata[0],
              statedata.size()-1, 
               nullptr,          //typeid
               nullptr,          //explicitscope
               0,                //matching stamp
               0                 //check stamp
            )
         );
      }

      statedata getStateData()
      {
         statedata wnf_state_buffer(8192);
         auto state_buffer_size = static_cast<unsigned long>( wnf_state_buffer.size());

         misc::wnf::WNF_CHANGE_STAMP wnf_change_stamp{ 0x00 };
         THROW_IF_NTSTATUS_FAILED(
            misc::wnf::NtQueryWnfStateData(
               &name,
               nullptr,
               nullptr,
               &wnf_change_stamp,
               &wnf_state_buffer[0],
               &state_buffer_size
            )
         );
         wnf_state_buffer.resize(state_buffer_size);
         return wnf_state_buffer;
      }
   private:
      misc::wnf::WNF_STATE_NAME strToStateName(unistr unparsed)
      {
         if (unparsed.starts_with(L"0x"))
         {
            auto a = unparsed.size();
            if (unparsed.size() != 18) throw std::exception{ "wnf ids are 18 chars " };
            auto withOutHexNoti = unparsed.substr(2);

            auto firstPart = withOutHexNoti.substr(0, 8);
            auto firstPartNum = std::stoul(firstPart, nullptr, 16);

            auto secondPart = withOutHexNoti.substr(8);
            auto secondPartNum = std::stoul(secondPart, nullptr, 16);

            return misc::wnf::WNF_STATE_NAME{ secondPartNum, firstPartNum };
         }
         else
         {
            if (!unparsed.starts_with(L"WNF_")) unparsed = L"WNF_"s + unparsed;
            return misc::wnf::wnf_id.at(unparsed);
         }
      }
   };
}

namespace objdir
{
   namespace details
   {
      std::vector< std::pair< std::wstring, std::wstring > > getChildren( ::HANDLE handle ) 
      {
         ULONG index = 0, bytes;
         BOOLEAN firstEntry = TRUE;
         int start = 0;

         std::vector< std::pair< std::wstring, std::wstring > > list{};
         auto bufsize = 0xFF00;
         std::vector<char> buf;
         buf.resize(bufsize);
         NTSTATUS status;

         do {
            _OBJECT_DIRECTORY_INFORMATION* _buffer = (_OBJECT_DIRECTORY_INFORMATION*)&buf[0];

            bool bigenough = false;
            while ( ! bigenough )
            {
              status = NtQueryDirectoryObject(handle, _buffer, bufsize, FALSE, firstEntry, &index, &bytes);
               bigenough = (status != STATUS_BUFFER_TOO_SMALL) ;
               if( ! bigenough )
               {
                  bufsize = bufsize * 2;
                  buf.resize(bufsize);
                  _buffer = (_OBJECT_DIRECTORY_INFORMATION*)&buf[0];
               }
            }

            for( ULONG i = index - start -1; i >0; --i )
            {
               std::wstring name{ _buffer[i].Name.Buffer,((static_cast<unsigned int>(_buffer[i].Name.Length))  /2)  };
               std::wstring type{ _buffer[i].TypeName.Buffer ,((static_cast<unsigned int>(_buffer->TypeName.Length))  /2)     };
           
               list.push_back( 
                  std::make_pair( 
                     name,
                     type
                  ) 
               );
            }
           
            start = index;
            firstEntry = FALSE;
         } while(status == STATUS_MORE_ENTRIES);
         std::sort(list.begin(), list.end());
         return list;
      } 
      
      struct open : public NTObj< open, &NtOpenDirectoryObject > {
         open( unistr objName, ACCESS_MASK DesiredAccess = MAXIMUM_ALLOWED )
            : NTObj< open, &NtOpenDirectoryObject >  { DesiredAccess, objName } 
         {}        
         auto children(){ return getChildren( this->getHandle() ); }

         template< typename T>
         auto operator/ (T s) {
             return getNTPath() / s;
         }

      };
      
      struct create : public NTObj< create ,  &NtCreateDirectoryObjectEx > {
         template< typename T >
         create(  T objName, ::HANDLE shadowDir = nullptr, ACCESS_MASK DesiredAccess = MAXIMUM_ALLOWED )
            : NTObj< create,  &NtCreateDirectoryObjectEx > { DesiredAccess, objName, shadowDir, 0 }
            { 
            }
         auto children(){ return getChildren( this->getHandle() ); }


         template< typename T>
         auto operator/ (T s) const {
             return getNTPath() / s;
         }

      };
   }
   namespace exportNS 
   {
      using create = details::create ;
      using open   = details::open;
   }
   using namespace exportNS;
}

namespace symlink
{
   struct symlink : public NTObj< symlink, &NtCreateSymbolicLinkObject > {
      symlink(strpath objName, strpath target, ACCESS_MASK DesiredAccess = MAXIMUM_ALLOWED)
         : NTObj< symlink, &NtCreateSymbolicLinkObject >{ DesiredAccess,  objName , target }
      {}
   }; 

   struct existingSymlink : public NTObj< existingSymlink, &NtOpenSymbolicLinkObject > {
      existingSymlink(strpath objName )
         : NTObj< existingSymlink, &NtOpenSymbolicLinkObject >{ DELETE,  objName   }
      {}
   };
}
 
 

IMPORTAPI( L"ntdll.dll", NtRenameKey, NTSTATUS, HANDLE , PUNICODE_STRING );

IMPORTAPI( L"ntdll.dll", NtLoadKeyEx, NTSTATUS, POBJECT_ATTRIBUTES ,POBJECT_ATTRIBUTES ,ULONG,HANDLE,HANDLE,ACCESS_MASK,PHANDLE,PIO_STATUS_BLOCK);



namespace process
{
   std::vector< THREADENTRY32 > getAllThreads()
   {
      std::vector< THREADENTRY32 > allThreads;
      HANDLE hThreadSnap = CreateToolhelp32Snapshot(TH32CS_SNAPTHREAD, 0);

      if (hThreadSnap != ((::HANDLE) - 1)) {
         THREADENTRY32 th32;
         th32.dwSize = sizeof(THREADENTRY32);
         BOOL bOK = TRUE;

         for (bOK = Thread32First(hThreadSnap, &th32); bOK; bOK = Thread32Next(hThreadSnap, &th32)) {
            allThreads.emplace_back(th32);
         }
      }
      CloseHandle(hThreadSnap);
      return allThreads;
   }

   std::map<DWORD, PROCESSENTRY32 > getAllProcesses() {
      std::map<DWORD, PROCESSENTRY32 > allProcesses;

      HANDLE hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
      if (hSnapshot)
      {
         PROCESSENTRY32  peInfo;
         peInfo.dwSize = sizeof(peInfo); // this line is REQUIRED
         BOOL nextProcess = Process32First(hSnapshot, &peInfo);

         while (nextProcess)
         {
            allProcesses.emplace(peInfo.th32ProcessID, peInfo);
            nextProcess = Process32Next(hSnapshot, &peInfo);
         }
         CloseHandle(hSnapshot);

         return allProcesses;
      }
      else { throw std::exception{ "An error happened retreiving processes" }; }
   }
   struct procThread {
       handle process;
       handle thread;
   };
   auto execute( strpath executable , std::wstring args = L"", std::wstring currDir = L"", bool suspended = false,HANDLE token = GetCurrentThreadToken() )
   {
      STARTUPINFO startInfo = { 0x00 };
      startInfo.cb = sizeof(startInfo);
      startInfo.wShowWindow = SW_SHOW;
      startInfo.lpDesktop = const_cast<wchar_t*>(L"WinSta0\\Default");

      PROCESS_INFORMATION procInfo = { 0x00 };

      HANDLE hToken = {};

      DuplicateTokenEx(token, TOKEN_ALL_ACCESS, nullptr, SecurityAnonymous, TokenPrimary, &hToken);   


       if (CreateProcessAsUser(hToken,
         executable.c_str(),
         const_cast<wchar_t*>( args.c_str() ),
         nullptr,
         nullptr,
         FALSE,
         NORMAL_PRIORITY_CLASS | CREATE_NEW_CONSOLE | ( suspended ? CREATE_SUSPENDED : 0 ),
         nullptr,
         nullptr,
         &startInfo,
         &procInfo
      )
         ) {
 
           return procThread{ handle::make(procInfo.hProcess), handle::make(procInfo.hThread) };
      }
       THROW_LAST_ERROR();
   }



   void ShellExecute(std::wstring arg, std::wstring exeArgString = L"", LPCWSTR dirStr = nullptr, int cmdShow = SW_SHOW)
   {
      SHELLEXECUTEINFO shex = {
         sizeof(shex)
         , SEE_MASK_NOCLOSEPROCESS
         , (HWND)nullptr
         , nullptr
         , arg.c_str()
         , exeArgString.c_str()
         , dirStr
         , static_cast<WORD>(cmdShow)
      };

      std::wcout << "Using Shell launch: %ls %ls"_u.format(shex.lpFile, shex.lpParameters) << std::endl;
      THROW_LAST_ERROR_IF_MSG(!ShellExecuteEx(&shex), "ERROR: Failed to create shell process");

      CloseHandle(shex.hProcess);
   }

   struct PROCESS_DEVICEMAP_INFORMATION {
      ::HANDLE DirectoryHandle;
   };

   bool SetProcessDeviceMap(HANDLE hDir, HANDLE hProc = GetCurrentProcess()) {
      PROCESS_DEVICEMAP_INFORMATION DeviceMap = { hDir };
      NTSTATUS status = NtSetInformationProcess(hProc,
         ProcessDeviceMap,
         &DeviceMap,
         sizeof(DeviceMap));
      return status == 0;
   }

}


/*NTSYSCALLAPI
NTSTATUS
NTAPI
NtLoadKeyEx(
    _In_ POBJECT_ATTRIBUTES TargetKey,2
    _In_ POBJECT_ATTRIBUTES SourceFile,
    _In_ ULONG Flags,
    _In_opt_ HANDLE TrustClassKey,
    _In_opt_ HANDLE Event,
    _In_opt_ ACCESS_MASK DesiredAccess,
    _Out_opt_ PHANDLE RootHandle,
    _Out_opt_ PIO_STATUS_BLOCK IoStatus
    );
 
#pragma comment(lib, "Ntdll.lib")*/
namespace signals
{
   struct signal : public NTObj< signal, &NtCreateEvent > 
   {
      std::wstring name;

      template< typename T >
      signal( T objName, ACCESS_MASK DesiredAccess = EVENT_ALL_ACCESS )
         : name{ objName },NTObj< signal, &NtCreateEvent >
         { 
            DesiredAccess,
            objattr{ 0, unistr{ "\\BaseNamedObjects\\%ls" }.format(objName),
            OBJ_OPENIF | OBJ_CASE_INSENSITIVE}, 
            NotificationEvent, 
            false 
         }
      {}

      void waitForSignal( DWORD timeout = INFINITE ) {
         std::wcout << L"waiting for signal:" << name << std::endl;
         WaitForSingleObject( getHandle(), timeout );
      }

      void signalPulse() {
         std::wcout << L"signalling:" << name << std::endl;
         LONG prevState = 0;
         THROW_IF_NTSTATUS_FAILED  ( NtSetEvent( getHandle(), &prevState ) );
      }
   };

}
namespace registry
{
 
   auto loadKey( strpath registry_destination,  strpath hivefile)
   {
      OBJECT_ATTRIBUTES dest{ 
        sizeof( OBJECT_ATTRIBUTES ),
        0,
        registry_destination.asUNICODE_STRING(),
        OBJ_CASE_INSENSITIVE, 
        NULL, 
        NULL 
      };

      OBJECT_ATTRIBUTES src{ 
        sizeof( OBJECT_ATTRIBUTES ),
        0,
        hivefile.asUNICODE_STRING(),
        OBJ_CASE_INSENSITIVE, 
        NULL, 
        NULL
      };

      HANDLE h;
   /*
      int c = 0;
      while (true)
      {
         try{
         THROW_IF_NTSTATUS_FAILED(NtLoadKeyEx(&dest, &src, c++, (HANDLE)0, (HANDLE)0, MAXIMUM_ALLOWED, &h, nullptr));
         std::wcout << L"SUCCESS" << std::endl;
         }
         catch (wil::ResultException& e)
         {
            std::wcout << _com_error{ (HRESULT)RtlNtStatusToDosError(e.GetErrorCode()) }.ErrorMessage() << std::endl;
            std::wcout << e.what() << std::endl;

         }
      }*/
      THROW_IF_NTSTATUS_FAILED( NtLoadKeyEx( &dest, &src, 0x10,(HANDLE)0 ,(HANDLE)0 ,MAXIMUM_ALLOWED ,&h , nullptr  ) );
      std::wcout << L"Loaded " << hivefile << " to " << registry_destination << std::endl;

      return handle::make( h );
   } 

   void unloadKey( strpath registry_key )
   {
      OBJECT_ATTRIBUTES regKey{ 
        sizeof( OBJECT_ATTRIBUTES ),
        0,
        registry_key.asUNICODE_STRING(),
        OBJ_CASE_INSENSITIVE, 
        NULL, 
        NULL 
      };
   
      THROW_IF_NTSTATUS_FAILED( NtUnloadKey( &regKey ) );
   
      std::wcout << L"unloaded " << registry_key << std::endl;
   }

   template< typename T = unistr >
   struct regValType
   {
       T val;
       ULONG type{};
       regValType(T value, ULONG type = REG_SZ) :val{ value }, type{ type }{}
       PVOID value() { return (PVOID) val.c_str(); }
       auto len() { return val.length() * 2; }
   };
   template< typename T> regValType(T) -> regValType<T>;

   template< >
   struct regValType<int>  {
       int val;
       ULONG type{};
       regValType(int value, ULONG type = REG_DWORD) :val{ value }, type{ type }{}
       PVOID value() { return &val; }
       ULONG len() {
           return sizeof(val);
       }
   };

   class regval 
   {
      const handle hRregKey;
      const unistr valName;

public:
      regval( handle hRregKey, unistr valName ) : hRregKey{ hRregKey }, valName{ valName } {}
 
      template<typename T>
      T operator= (T value)
      {
          auto v = regValType{ value };

           THROW_IF_NTSTATUS_FAILED( NtSetValueKey(hRregKey, valName.asUNICODE_STRING(), 0, v.type, v.value(),static_cast<ULONG>( v.len() ) ) );
          return value;
      }

       operator std::wstring() const
       {
         ULONG ulSize;
         auto status =  NtQueryValueKey(
                            hRregKey,
                            valName.asUNICODE_STRING(),
                            KeyValuePartialInformation,
                            NULL,
                            0,
                            &ulSize
                        );

         if( status != STATUS_BUFFER_TOO_SMALL ) { THROW_IF_NTSTATUS_FAILED( status ); }

         std::vector< char > valueBuf{0x00};
         valueBuf.resize( ulSize );
         std::fill_n( &valueBuf[0], ulSize, 0x00 );

         PKEY_VALUE_PARTIAL_INFORMATION value = (PKEY_VALUE_PARTIAL_INFORMATION)  &valueBuf[0];

         THROW_IF_NTSTATUS_FAILED(  
            NtQueryValueKey(
                hRregKey,
                valName.asUNICODE_STRING(),
                KeyValuePartialInformation,
                value,
                ulSize,
                &ulSize
            )
         );

         return { std::wstring{ (wchar_t*) &value->Data[0] , ((wchar_t*) &value->Data[0] ) + ulSize } };
      }

      friend std::wostream& operator<<( std::wostream& os, const regval& me ) { return  os <<  static_cast< std::wstring >( me ); }
   };
#define REG_OPTION_PREDEF_HANDLE (0x01000000L)
#define REG_PREDEF_HANDLE_MASK   (0x80000000L)
   class regKey : public NTObj< regKey, &NtCreateKey >
   {
      ULONG disposition{0x00};

      auto  getHandl2e()  {
         return   getHandle();
      }

      template<typename T>
      T regRoot(T t) { return t; }
      template<>
      strpath regRoot(strpath t) { return regpath{ t }; }
        
      regKey( objattr o, bool volatilekey = true, ACCESS_MASK DesiredAccess = MAXIMUM_ALLOWED)
         : NTObj< regKey, &NtCreateKey >
      {
          DesiredAccess,
          o,
          0,
          nullptr,
          REG_OPTION_OPEN_LINK | (volatilekey ? REG_OPTION_VOLATILE : REG_OPTION_NON_VOLATILE),
          &disposition
      } {}
   public:
      template<typename T=const wchar_t*>
      regKey( handle h, T objName=L"", bool volatilekey = true,   ACCESS_MASK DesiredAccess = MAXIMUM_ALLOWED )
         : NTObj< regKey, &NtCreateKey >
      { 
          DesiredAccess,
          objattr{ h, regRoot(std::forward<T>(objName)), OBJ_OPENLINK  | OBJ_OPENIF | OBJ_CASE_INSENSITIVE },
          0, 
          nullptr,
          REG_OPTION_PREDEF_HANDLE|REG_OPTION_OPEN_LINK | (volatilekey ? REG_OPTION_VOLATILE : REG_OPTION_NON_VOLATILE),
          &disposition 
      } {}
         

      void deleteKey() { THROW_IF_NTSTATUS_FAILED( NtDeleteKey(wrappedHandle) ); }

      void renameKey( strpath newName ){ THROW_IF_NTSTATUS_FAILED( NtRenameKey( wrappedHandle, newName.asUNICODE_STRING() ) ); }

      auto operator[] ( unistr valueName ) { return regval{ wrappedHandle, valueName }; }

      auto getSubKeys() {
         std::array<wchar_t,MAX_PATH> achKey{0x0000};
         std::array<wchar_t,MAX_PATH> achClass{0x0000};
         DWORD    cchClassName = MAX_PATH;
         DWORD    cSubKeys = 0;               // number of subkeys
         DWORD    cbMaxSubKey;              // longest subkey size 
         DWORD    cchMaxClass;    
         DWORD    cValues;              // number of values for key 
         DWORD    cchMaxValue;          // longest value name 
         DWORD    cbMaxValueData;       // longest value data 
         DWORD    cbSecurityDescriptor; // size of security descriptor 
         FILETIME ftLastWriteTime;      // last write time 
         HKEY hKey =  (HKEY) static_cast<HANDLE>(wrappedHandle);
         auto retCode = RegQueryInfoKey(          hKey,                    // key handle 
                                                  &achClass[0],                // buffer for class name 
                                                  &cchClassName,           // size of class string 
                                                  NULL,                    // reserved 
                                                  &cSubKeys,               // number of subkeys 
                                                  &cbMaxSubKey,            // longest subkey size 
                                                  &cchMaxClass,            // longest class string 
                                                  &cValues,                // number of values for this key 
                                                  &cchMaxValue,            // longest value name 
                                                  &cbMaxValueData,         // longest value data 
                                                  &cbSecurityDescriptor,   // security descriptor 
                                                  &ftLastWriteTime);       // last write time 
         std::vector<std::wstring> vecKeys;
         if ( cSubKeys )
         {
            vecKeys.reserve(cSubKeys);
            for ( unsigned int i = 0; i < cSubKeys; ++i )
            {
               DWORD cbName = 255;
               retCode = RegEnumKeyEx(hKey, i, &achKey[0], &cbName, NULL, NULL, NULL, &ftLastWriteTime);
               if (retCode == ERROR_SUCCESS)
               {
                  vecKeys.push_back( &achKey[0] );
               }
            }
         }
         return vecKeys;
      }
   }; 

   struct createRegLinkKey : public NTObj< createRegLinkKey, &NtCreateKey > 
   {

      ULONG disposition{0x00};
    
      createRegLinkKey( handle handle, unistr relname = L"", bool volatilekey =true, ACCESS_MASK DesiredAccess = KEY_ALL_ACCESS )
         : NTObj< createRegLinkKey, &NtCreateKey >{
         DesiredAccess,
         objattr{ handle, relname , OBJ_CASE_INSENSITIVE| OBJ_OPENLINK | OBJ_OPENIF },
         0,
         nullptr,
            REG_OPTION_OPEN_LINK ,
         &disposition
      } {}

      createRegLinkKey( unistr objName, bool volatilekey = true , ACCESS_MASK DesiredAccess = KEY_ALL_ACCESS )
         : NTObj< createRegLinkKey, &NtCreateKey >  {
         DesiredAccess, 
         objattr{ 0, objName, OBJ_CASE_INSENSITIVE | OBJ_OPENLINK | OBJ_OPENIF},
         0,
         nullptr, 
          REG_OPTION_CREATE_LINK | REG_OPTION_OPEN_LINK | (volatilekey ? REG_OPTION_VOLATILE : REG_OPTION_NON_VOLATILE ),
         &disposition 
      } {}

    
      createRegLinkKey(objattr  objName, bool volatilekey = false, ACCESS_MASK DesiredAccess = KEY_ALL_ACCESS)
         : NTObj< createRegLinkKey, &NtCreateKey >{
         DesiredAccess,
           objName ,
         0,
         nullptr,
         REG_OPTION_CREATE_LINK | REG_OPTION_OPEN_LINK | (volatilekey ? REG_OPTION_VOLATILE : REG_OPTION_NON_VOLATILE),
         &disposition
      } {}

      template< typename T >
      createRegLinkKey(T objName, bool volatilekey = true , ACCESS_MASK DesiredAccess = KEY_ALL_ACCESS)
        : NTObj< createRegLinkKey, &NtCreateKey >  {
        DesiredAccess, 
        objattr { 0, objName, OBJ_CASE_INSENSITIVE },
        0,
        nullptr, 
        REG_OPTION_CREATE_LINK | (volatilekey ? REG_OPTION_VOLATILE : REG_OPTION_NON_VOLATILE),
        &disposition
      } {}

      void renameKey( strpath newName){ THROW_IF_NTSTATUS_FAILED( NtRenameKey( wrappedHandle, newName.asUNICODE_STRING() ) ); }

      void deleteKey( ) { THROW_IF_NTSTATUS_FAILED( NtDeleteKey(wrappedHandle) ); }

      void setLinkDestination( strpath destination ) {
         regval{ wrappedHandle, L"SymbolicLinkValue" } =regValType{ destination, REG_LINK};
      }

      auto getLinkDestination() {
         return static_cast< std::wstring >( regval{ wrappedHandle, L"SymbolicLinkValue" } ); 
      }
       
   }; /*

   void dumpRegRoots()
   {
      for(auto& rootKeyName :  regKey{ "" }.getSubKeys() )
      {
         try {
            auto croot = regKey{ rootKeyName };
            for (auto& keyName : croot.getSubKeys())
            {
               for (auto& k : regKey{ croot , keyName }.getSubKeys())
               {
                  try {
                     
                     regKey{  "\\registry\\"_p / rootKeyName /  "\\"_p / keyName /  "\\"_p / k };

                     std::wcout << L"\t" << keyName << std::endl;
                  }
                  catch (...) { std::wcout << L"registry::regKey \\REGISTRY\\"s << rootKeyName << L" could not be opened" << std::endl; }
               }




            }
         }
         catch (...) { std::wcout << L"registry::regKey \\REGISTRY\\"s << rootKeyName << L" could not be opened" << std::endl; }
      }
   }*/
}

