#pragma once

#include "../../pch.h"  
#include "wil/result.h"
#include "NTcore.h"
#include "str.h"  
#include "misc.h" 
#include "str.h"
#include "reparsePoints.h"
 using namespace reparsePoint;
 
#define FILE_SHARE_ALL FILE_SHARE_DELETE | FILE_SHARE_READ | FILE_SHARE_WRITE
 
class file : public NTObj< file, &ZwCreateFile > 
{
private:
   IO_STATUS_BLOCK IoStatus {};
public:
 template<typename T>
    explicit file
    (
     T path,
      DWORD DesiredAccess = FILE_GENERIC_READ,
      DWORD dwAdditionalOptions = 0,
      DWORD dwCreateDisposition = FILE_OPEN_IF,
      DWORD dwShareMode = FILE_SHARE_ALL
    ) :
      NTObj< file, &ZwCreateFile >
      {
            DesiredAccess | SYNCHRONIZE,
          objattr{  path  },
            &IoStatus,
            nullptr,
            0,
            dwShareMode,
            dwCreateDisposition,
            dwAdditionalOptions ,
            nullptr,
            0
      } 
    {}
   
   template<typename T> friend T& operator<<(T& os,  file& dt) 
   { return (os << unistr{ dt.getFinalPath().substr(4) }); }
 
   template<typename T> T& operator<<( T& os ) const 
   { return(os << unistr{ getFinalPath().substr(4) }); }
  
   template< typename T>  auto operator/ ( T s ) 
   { return this->getNTPath() / s;  }
  
   operator strpath() { return getFinalPath(); }

   void setTimeToOld()
   {
      constexpr auto _SECOND  = ((unsigned int)10000000);
      constexpr auto _MINUTE  = (60 * _SECOND);
      constexpr auto _HOUR    = (60 * _MINUTE);
      constexpr auto _DAY     = (24 * _HOUR);

      FILETIME ft;
      SYSTEMTIME st;
      GetSystemTime(&st);              // Gets the current system time
      SystemTimeToFileTime(&st, &ft);  // Converts the current system time to file time format
  
      ULONGLONG qwResult;

      // Copy the time into a quadword.
      qwResult = (((ULONGLONG)ft.dwHighDateTime) << 32) + ft.dwLowDateTime;

      // Add 30 days.
      qwResult -= 4 * _DAY;

      // Copy the result back into the FILETIME structure.
      ft.dwLowDateTime  = (DWORD)(qwResult & 0xFFFFFFFF);
      ft.dwHighDateTime = (DWORD)(qwResult >> 32);
      ft.dwLowDateTime  = 0xFFFFFFFF;
      ft.dwHighDateTime = 0;
      THROW_LAST_ERROR_IF(
         false == SetFileTime( getHandle(),  // Sets last-write time of the file 
                               &ft,          // to the converted current system time 
                               &ft,
                               &ft
                             )
      );
   }

   template<typename T>
   auto monitorFolderChanges( bool recursive, wil::FolderChangeEvents listenFor, T&& callback )
   {
      return std::move( wil::make_folder_change_reader( getFinalPath().c_str(), recursive, listenFor, std::forward<T>( callback ) ) );
   }
   
   typedef struct _FILE_MEMORY_PARTITION_INFORMATION {
      ULONG_PTR OwnerPartitionHandle;
      union {
          struct {
              UCHAR NoCrossPartitionAccess;
              UCHAR Spare[3];
          } DUMMYSTRUCTNAME;

          ULONG AllFlags;
      } Flags;
  } FILE_MEMORY_PARTITION_INFORMATION, *PFILE_MEMORY_PARTITION_INFORMATION;
 
   /*if you call FileMemoryPartitionInformation, following checks happen:
  Length is checked to be large enough to fit structure.
  Flags.NoCrossPartitionAccess <= true
  AllFlags must be zero except NoCrossPartitionAccess
  then a pool "fPoI" is allocated.
  */

   auto getMemPartition()
   {
      IO_STATUS_BLOCK           io;
      FILE_MEMORY_PARTITION_INFORMATION mi{ 0x00 };

      THROW_IF_NTSTATUS_FAILED(NtQueryInformationFile(getHandle(), &io, &mi, sizeof(FILE_MEMORY_PARTITION_INFORMATION), FileMemoryPartitionInformation));
      return mi;
   }
   
   auto getVolumeId()
   {
      IO_STATUS_BLOCK io;
      FILE_FS_OBJECTID_INFORMATION fi{ 0x00 };

      THROW_IF_NTSTATUS_FAILED( NtQueryVolumeInformationFile( getHandle(), &io, &fi, sizeof(fi), FileFsObjectIdInformation) );

      std::string s{ (char*)&fi.ObjectId[0], 0x0f+1 };
      std::wstringstream r;
      for (unsigned char c : s)
      {
         r << std::hex << std::uppercase << static_cast<unsigned int>(c);
      }
     
      return r.str();
   }
        
   auto getFileId()
   {
      IO_STATUS_BLOCK           io;
      FILE_INTERNAL_INFORMATION fi;

      THROW_IF_NTSTATUS_FAILED( NtQueryInformationFile( getHandle(), &io, &fi, sizeof( fi ), FileInternalInformation ) );
             
      return unistr( fi.IndexNumber.QuadPart );
   }
 
   template<typename T>
   struct fileinf   
   {
      T inf;
      std::wstring FileName;

      template<typename T>
      fileinf(T t, std::wstring FileName) : inf{ t }, FileName { FileName } {}
      
      std::wostream& operator<< (std::wostream& out ) {
         return out << this->FileName;
      }
   };
   template< typename T > fileinf(T, std::wstring)  -> fileinf< T > ;


   template< typename T = FILE_FULL_DIR_INFORMATION, auto U = FileFullDirectoryInformation >
   std::vector< fileinf<T> > enumDir()
   { 
      unsigned long dir_entries_buffer_size = 0xfff00;
      typed_buffer_ptr< T > dir_entries_buffer(dir_entries_buffer_size);

      std::vector< fileinf<T> > content;
      //	
      T* entry = dir_entries_buffer ;
      IO_STATUS_BLOCK io_status{ 0x00 };
      bool first_iteration = TRUE;

      for (;; entry) {
         if ( ! NT_SUCCESS(
            ZwQueryDirectoryFile( getHandle(), NULL, NULL, 0, &io_status, dir_entries_buffer, dir_entries_buffer_size, U, FALSE, NULL, first_iteration)
         ) ) break;
         
         entry = dir_entries_buffer ;

         for (;;) 
         {
            std::wstring fname{ entry->FileName,entry->FileNameLength / 2 };
            if (fname != L"." && fname != L".." && fname.length() != 0)
            {
               fileinf fi{ *entry,fname };
                
               content.emplace_back(fi);
            }
            
            if (entry->NextEntryOffset == 0)
               return content;
            entry = (T*)(((char*)entry) + entry->NextEntryOffset);
       
         }
         first_iteration = FALSE;
      }
      return content;
   }

   strpath getFinalPath() const
   {
      wchar_t path[MAX_PATH]{ 0x0000 };

      try {
         THROW_LAST_ERROR_IF(0 == GetFinalPathNameByHandle(getHandle(), path, MAX_PATH, 0));
      } catch (...) { return L"errorFile"; };

      return  path  ;
   } 
   
   void rename( ntpath NTNewName, ::HANDLE newDir = nullptr ) const
   {
      const unsigned int  FILE_RENAME_IGNORE_READONLY_ATTRIBUTE = 0x00000040;

      auto oldFilename = getFinalPath();

      typed_buffer_ptr< FILE_RENAME_INFO > RENAMEINFO {
         sizeof( FILE_RENAME_INFO ) + ( NTNewName.size() * sizeof( WCHAR ) ) - sizeof( WCHAR )
      };
      RENAMEINFO->RootDirectory   = newDir;
      RENAMEINFO->Flags = FILE_RENAME_REPLACE_IF_EXISTS | FILE_RENAME_POSIX_SEMANTICS | FILE_RENAME_IGNORE_READONLY_ATTRIBUTE;
      RENAMEINFO->ReplaceIfExists = TRUE;
      RENAMEINFO->FileNameLength  = static_cast<DWORD>( NTNewName.size() * sizeof( WCHAR ) );
      memcpy( &RENAMEINFO->FileName[ 0 ], NTNewName.c_str(), NTNewName.size() * sizeof( WCHAR ) );

      IO_STATUS_BLOCK io_status { 0x00 };
      THROW_IF_NTSTATUS_FAILED( 
         ZwSetInformationFile(  getHandle(), &io_status, RENAMEINFO, static_cast<DWORD>( RENAMEINFO.size() ), FileRenameInformation ) 
      );
       
      // splitted in two because order of evaluation will invaildate cache before retreived
      std::wcout <<   oldFilename + L": Renamed to:" +  getNTPath() + L"\n" << std::endl;
   }

   template< auto logger = &std::wcout >
   void deleteFile () const 
   {
      FILE_DISPOSITION_INFORMATION fd { 0x00 };
      fd.DeleteFile = true;

      IO_STATUS_BLOCK io_status { 0x00 };
      THROW_IF_NTSTATUS_FAILED( ZwSetInformationFile( getHandle(), &io_status, &fd, sizeof( FILE_DISPOSITION_INFORMATION ), FileDispositionInformation ));
       
      *logger << ( getNTPath() + L": Was marked for deletion"s ) << std::endl;
   }

   void setAttrToNormal() 
   {
      FILE_BASIC_INFORMATION BasicInfo;
      memset(&BasicInfo, 0xFF, sizeof(FILE_BASIC_INFORMATION));

      BasicInfo.FileAttributes = FILE_ATTRIBUTE_NORMAL;

      IO_STATUS_BLOCK IoStatus;
      THROW_IF_NTSTATUS_FAILED(
         NtSetInformationFile(getHandle(),
         &IoStatus,
         &BasicInfo,
         sizeof(FILE_BASIC_INFORMATION),
         FileBasicInformation)
      );
   }

   auto ioControl(DWORD ctrlCode,std::vector<byte> inbuf, std::vector<byte>& outbuf) {
      DWORD dwBytesReturned;
      THROW_LAST_ERROR_IF(!
         DeviceIoControl(
            getHandle(),
            ctrlCode,
            &inbuf[0],
            inbuf.size(),
            &outbuf[0],
            outbuf.size(),
            &dwBytesReturned,
            NULL
         )
      );
      return dwBytesReturned;
   }


   std::wstring getObjId( )
   {
      const char ValueToChar[17]{ "0123456789ABCDEF" };

      FILE_OBJECTID_BUFFER ObjId = { 0 };
     
      PBYTE objid =(PBYTE) &ObjId;
      
      DWORD dwBytesReturned;
      THROW_LAST_ERROR_IF( !
         DeviceIoControl(
            getHandle(),
            FSCTL_GET_OBJECT_ID,
            NULL,
            0,
            &ObjId,
            sizeof(FILE_OBJECTID_BUFFER),
            &dwBytesReturned,
            NULL
         )
      );

      char objIdstr[40]{ 0x00 };
      auto* pobjIdstr = &objIdstr[0];
      for (int i = 0; i < 0x10; i++)
      {
         BYTE OneByte = *(objid++);

         *pobjIdstr++ = ValueToChar[OneByte >> 0x04];
         *pobjIdstr++ = ValueToChar[OneByte & 0x0F];
      }

      *pobjIdstr = 0;
      return unistr{ &objIdstr[0] };
   }

   template< auto logger = &std::wcout >
   void setreparsePoint(  unistr reparsePoint) const
   {
      reparsePoint::setReparsePoint(getHandle(), reparsePoint);
      *logger << (getFinalPath() + L" reparse point applied\n");
   }

   template< auto logger = &std::wcout >
   void delete_reparse_point( DWORD tag = IO_REPARSE_TAG_SYMLINK) const
   {
      reparsePoint::delete_reparse_point(getHandle(), tag);
      *logger << (getFinalPath() + L": deleted reparse point to:"s + L"\n"s) << std::endl;

   }

   template< auto logger = &std::wcout >
   void makeappexec(  std::wstring appPackageId, std::wstring AppUserModelID, std::wstring targetPath) const
   {
      reparsePoint::makeappexec(getHandle(),appPackageId, AppUserModelID, targetPath);
      *logger << (getFinalPath() + L": Made appExec reparse point\n") << std::endl;
   }

   template< auto logger = &std::wcout >
   void makeJunction( ntpath target ) const
   {
      reparsePoint::makeJunction( getHandle(), target );
      *logger << (getFinalPath() + L": Created junction point to:"s + target + L"\n");
   }

   template< auto logger = &std::wcout >
   void makeSymlink(  ntpath target) const
   {
      //doMakeSymlink(getHandle(), target);
      *logger << (getFinalPath() + L": Created symbolic link to:"s + target + L"\n");

   }

   template< auto logger = &std::wcout >
   void changereparsePoint(ntpath target, ULONG existingReparseTag = 0) const
   {
      reparsePoint::changeReparsePoint(getHandle(), target, existingReparseTag);
      * logger << (getFinalPath() + L" reparse point updated\n");
   }

   void printreparsePoint() const
   {
      doPrintReparsePoint( getHandle() );
   }

   void setObjId(std::wstring objId)
   {
      DWORD dwBytesReturned;
      FILE_OBJECTID_BUFFER objidbuf = { 0x00 };
    
      PBYTE pbObjectID = (PBYTE)objidbuf.ObjectId;
      DWORD dwLength = 0;
      TCHAR OneChar;
      BYTE OneByte;
      
      auto  szFileOrObjId = &objId[0];

      for (int i = 0; i < 0x10; i++)
      {
         if (objId[0] > 0x80 || objId[1] > 0x80) { throw std::exception("Invalid objid"); }

         // Convert the first character
         OneChar = *szFileOrObjId++;
         if (CharToValue[OneChar] == 0xFF)
         {
            throw std::exception("Invalid objid");
         }
         OneByte = CharToValue[OneChar] << 0x04;

         // Convert the second character
         OneChar = *szFileOrObjId++;
         if (CharToValue[OneChar] == 0xFF)
         {
            throw std::exception("Invalid objid");
         }
         OneByte |= CharToValue[OneChar];
         *pbObjectID++ = OneByte;
      }

      THROW_LAST_ERROR_IF(!
         DeviceIoControl(
            getHandle(), 
            FSCTL_SET_OBJECT_ID,
            &objidbuf,
            sizeof(FILE_OBJECTID_BUFFER),
            NULL,
            0,
            &dwBytesReturned,
            NULL
         )
      ); 
   }
 
   void dax()
   {
      DWORD dwResult;;
      THROW_LAST_ERROR_IF(!
         DeviceIoControl(getHandle(),
         FSCTL_ALLOW_EXTENDED_DASD_IO,
         NULL,
         0,
         NULL,
         0,
         &dwResult,
         NULL)
      );

   }
   template<typename T>
   auto makeoplock(T f) const{
      return misc::oplock{ *this, (f) };
   }

   auto getShortName( )  const
   {
      FILE_NAME_INFORMATION* a= (FILE_NAME_INFORMATION * )malloc(sizeof(FILE_NAME_INFORMATION) + 26);
      IO_STATUS_BLOCK io_status{ 0x00 };

      THROW_IF_NTSTATUS_FAILED(
         ZwQueryInformationFile(getHandle(), &io_status, a, 26, FileAlternateNameInformation)
      );
      return unistr{ a->FileName };
    }

   template< auto logger = &std::wcout >
   void setShortName(std::wstring  shortname)  const
   {
      typed_buffer_ptr< FILE_NAME_INFORMATION > name_info{
         sizeof(FILE_NAME_INFORMATION) + ((shortname.size() *2)-2)
      };
      name_info->FileNameLength = (shortname.size() * 2) ;
      memcpy(name_info->FileName, shortname.c_str(), (shortname.size() * sizeof(WCHAR)) );

      IO_STATUS_BLOCK io_status{ 0x00 };
      THROW_IF_NTSTATUS_FAILED(
         NtSetInformationFile(getHandle(), &io_status, name_info, name_info.size(), FileShortNameInformation)
      );

      *logger << std::wstring(getNTPath() + L": set short name to "s + shortname.c_str()) << std::endl;
   }
 
   template< auto logger = &std::wcout >
   void makeHardLink(  std::wstring  NTTarget )  const
   {         
      typed_buffer_ptr< FILE_LINK_INFORMATION > link_info { 
         sizeof( FILE_LINK_INFORMATION ) + ( NTTarget.size() * sizeof( WCHAR ) ) - sizeof( WCHAR )
      };

      link_info->ReplaceIfExists = TRUE;
      link_info->FileNameLength  = static_cast<ULONG>( NTTarget.size() * sizeof( WCHAR ) );
      memcpy( &link_info->FileName[ 0 ], NTTarget.c_str(), NTTarget.size() * sizeof( WCHAR ) );

      IO_STATUS_BLOCK io_status { 0x00 };
      THROW_IF_NTSTATUS_FAILED(
         ZwSetInformationFile( getHandle(), &io_status, link_info,static_cast<DWORD>( link_info.size() ), FileLinkInformation )
      );
       
      *logger << std::wstring( getNTPath() + L": Created an hard link at: "s + NTTarget.c_str() ) << std::endl;
   } 
    
   template< auto logger = &std::wcout >
   void renameFile( std::wstring renameTo ) const
   {
      typed_buffer_ptr< FILE_RENAME_INFO > RENAMEINFO { 
         static_cast<size_t>( sizeof( FILE_RENAME_INFO ) + ( renameTo.size() * sizeof( WCHAR ) ) - sizeof( WCHAR ) ) 
      };
      RENAMEINFO->RootDirectory   = 0;
      RENAMEINFO->ReplaceIfExists = TRUE;
      RENAMEINFO->FileNameLength  = static_cast<ULONG>( renameTo.size() * sizeof( WCHAR ) );
      memcpy( &RENAMEINFO->FileName[ 0 ], renameTo.c_str(),static_cast<size_t>( renameTo.size() * sizeof( WCHAR ) ) );

      IO_STATUS_BLOCK io_status { 0x00 };
      THROW_IF_NTSTATUS_FAILED( NtSetInformationFile( getHandle(), &io_status, RENAMEINFO, RENAMEINFO.size(), FileRenameInformation ));
    
      auto oldFilename =  getNTPath() ;  
      *logger <<  oldFilename + L": Renamed to:"s + renameTo + L"\n" ;
   }
         
   bool isDir()
   {
      typed_buffer_ptr< FILE_STANDARD_INFORMATION > standardInf{ sizeof(FILE_STANDARD_INFORMATION) };
   
      IO_STATUS_BLOCK io_status{ 0x00 };
      THROW_IF_NTSTATUS_FAILED(
         NtQueryInformationFile( getHandle(), &io_status, standardInf, static_cast<ULONG>( standardInf.size() ) , FileStandardInformation )
      );
      return standardInf->Directory ;
   }

   void setDaclEveryoneFull() const
   {
      SID_IDENTIFIER_AUTHORITY SIDAuthWorld = SECURITY_WORLD_SID_AUTHORITY;
      PSID everyoneSid = nullptr;
 
      EXPLICIT_ACCESS ea[2] = {};
      PACL acl = nullptr;
      SECURITY_DESCRIPTOR rpcSecurityDescriptor = {}; 

      // Get the SID form of the custom capability.  In this case we only expect one SID and
      // we don't care about the capability group. 
      //INSERT DERIVE CAPABILTY SIDS FROM NAME HERE
      DWORD hResult ;
      // Get the SID that represents 'everyone' (this doesn't include AppContainers)
      if (!AllocateAndInitializeSid(
         &SIDAuthWorld, 1,
         SECURITY_WORLD_RID,
         0, 0, 0, 0, 0, 0, 0,
         &everyoneSid))
      {
         hResult = GetLastError();
      }

      SID_IDENTIFIER_AUTHORITY SIDAuthNT = SECURITY_NT_AUTHORITY;
      PSID sysSid = nullptr;
      if (!AllocateAndInitializeSid(
         &SIDAuthNT, 1,
         SECURITY_LOCAL_SYSTEM_RID,
         0, 0, 0, 0, 0, 0, 0,
         &sysSid))
      {
         hResult = GetLastError();
      }

      // Everyone GENERIC_ALL access
      ea[0].grfAccessMode = SET_ACCESS;
      ea[0].grfAccessPermissions = GENERIC_EXECUTE;
      ea[0].grfInheritance = SUB_CONTAINERS_AND_OBJECTS_INHERIT;
      ea[0].Trustee.TrusteeForm = TRUSTEE_IS_SID;
      ea[0].Trustee.TrusteeType = TRUSTEE_IS_WELL_KNOWN_GROUP;
      ea[0].Trustee.ptstrName = static_cast<LPWSTR>(everyoneSid);

      // Custom capability GENERIC_ALL access
      ea[1].grfAccessMode = DENY_ACCESS;
      ea[1].grfAccessPermissions = WRITE_DAC;
      ea[1].grfInheritance = NO_INHERITANCE;
      ea[1].Trustee.TrusteeForm = TRUSTEE_IS_SID;
      ea[1].Trustee.TrusteeType = TRUSTEE_IS_WELL_KNOWN_GROUP;
      ea[1].Trustee.ptstrName = static_cast<LPWSTR>(sysSid);

      hResult = SetEntriesInAcl(ARRAYSIZE(ea), ea, nullptr, &acl);
       
      // Initialize an empty security descriptor
      if (!InitializeSecurityDescriptor(&rpcSecurityDescriptor, SECURITY_DESCRIPTOR_REVISION))
      {
         hResult = GetLastError();
      }

      // Assign the ACL to the security descriptor
      if (!SetSecurityDescriptorDacl(&rpcSecurityDescriptor, TRUE, acl, FALSE))
      {
         hResult = GetLastError();
      } 

      THROW_IF_WIN32_ERROR( SetSecurityInfo( wrappedHandle, SE_FILE_OBJECT, DACL_SECURITY_INFORMATION, 0 , 0 , acl ,0 ) );
   }

   void writedata ( std::string data ) 
   {
      DWORD written;
      auto success = WriteFile( getHandle() , data.c_str(), static_cast<DWORD>( data.size()  ), &written, nullptr);
      THROW_LAST_ERROR_IF(  static_cast<DWORD>( data.size() ) != written || !success );
    }

   std::vector<unsigned char> readdata()
   {
      LARGE_INTEGER size;
      GetFileSizeEx(getHandle(), &size);

      std::vector<unsigned char> data;
      data.resize(size.QuadPart +1);

      DWORD read;

      THROW_IF_WIN32_BOOL_FALSE(ReadFile(getHandle(), &data[0], size.QuadPart, &read, nullptr));
         
      return data;
   }

};  