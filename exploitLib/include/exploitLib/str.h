#pragma once
 
 
namespace fs = ::std::filesystem;

#define safecpy( src, dest ) lstrcpynW( dest, src, ARRAYSIZE( src ) )
#define safestrcpy( src, dest ) lstrcpynW( dest, src, wcslen( src ) )
 
static std::wstring_convert< std::codecvt_utf8< wchar_t >, wchar_t > strconverter; 

struct unistr ;
using namespace std::string_literals;

#include <Wincrypt.h>

#define BUFSIZE 1024
#define MD5LEN  16
 
struct unistr : public  std::wstring
{
private:

   static std::wstring s2ws(       std::wstring& str  ){ return str;                              }
   static std::wstring s2ws(       std::string&  str  ){ return strconverter.from_bytes(str); }
   static std::wstring s2ws( const std::wstring& str  ){ return str;                              }
   static std::wstring s2ws( const std::string&  str  ){ return strconverter.from_bytes(str); }
   static std::string  ws2s( const std::string&  str  ){ return str;                              }  
   static std::string  ws2s( const std::wstring& wstr ){ return strconverter.to_bytes(wstr);  }
   static std::string  ws2s(       std::wstring& wstr ){ return  strconverter.to_bytes(wstr);  }
   static std::string  ws2s(       std::string&  str  ){ return str;                              } 

   std::wstring intToHex(long long from, unsigned int width = 4) {
      std::wstringstream ws;
      ws << std::setw(width) << std::setfill(L'0') << std::hex << from;
      return L"0x"s + ws.str();
   }

public: 
   unistr(                                                                               ){} 
   unistr( std::string const& value       ) : std::wstring( s2ws(value )                ){}
   unistr( std::string& value             ) : std::wstring( s2ws(value )                ){}
   unistr( char const* in                 ) : std::wstring( in ? s2ws(in) : L""         ){}
   unistr( std::wstring const& wvalue     ) : std::wstring( wvalue                      ){}
   unistr( wchar_t const* val_array       ) : std::wstring( val_array ? val_array : L"" ){}
   unistr( fs::path filepath              ) : std::wstring( s2ws( filepath.string() )   ){}
   unistr( PUNICODE_STRING filepath       ) : std::wstring( filepath->Buffer            ){}
   unistr( unsigned long long i,int w = 4 ) : unistr{ intToHex(i,w)                     }{}

   std::string asString()    { return ws2s(*this); }
   std::string asString()  const  { return ws2s(*this); }
   std::wstring asWideString() { return  (*this); }
   std::wstring asWideString()  const { return  (*this); }

   //mutable std::vector<wchar_t> unibuf{0x0000};

 std::shared_ptr< wchar_t>    unibuf{ new wchar_t[this->length() * sizeof(wchar_t)] };


   mutable UNICODE_STRING ustr = UNICODE_STRING{ 
      static_cast< USHORT >( this->length() * sizeof( wchar_t )), 
      static_cast< USHORT >( this->length() * sizeof( wchar_t )), 
      const_cast< wchar_t* >( &unibuf.get()[0]  )
   };
   
   ~unistr()
   {
//      delete unibuf;
   }
  
   UNICODE_STRING* asUNICODE_STRING()   const 
   { 
     // std::shared_ptr<wchar_t[]> tmp(new wchar_t[this->length() * sizeof(wchar_t)]);
      
      USHORT len = static_cast<USHORT>( this->length() * sizeof( wchar_t ) );
  
      lstrcpynW(const_cast<wchar_t*>(&unibuf.get()[0]), (LPWSTR)this->c_str(), static_cast<int>( this->length() + 1 ) );

      ustr =  { len, len, const_cast< wchar_t* >(&unibuf.get()[0]) };
      return ( &ustr );     
   }

   operator std::string() const  { return asString();             }
   operator std::string()        { return asString();             }
   operator const char* ()       { return ws2s( * this ).c_str(); }
   operator const wchar_t* ()    { return this->c_str();          }
  
   unistr&  makelen(unsigned int width, wchar_t filler = L' ')
   {
      this->resize(width, filler);
      return *this;
   }
   template<typename T>
   friend std::ostream&  operator<< (std::ostream& out, const T& c){
         return out << c.asString().c_str();
   }
   template<typename T>
   friend std::wostream& operator<< (std::wostream& out, const T& c) {
      return out << c.asWideString().c_str();
   }

   bool isBlank(wchar_t c)
   {
      switch (c)
      {
      case L'\x20':
      case L'\x07':
      case L'\x09':
      case L'\r':
         return true;
      default:
         return false;
      }
   }

   void ltrim() {
      auto pos = 0;
      for (auto& c : *this) {
         pos++;
         if ( !isBlank(c)) {
            *this = this->substr(--pos);
            return;
         }
      }
   }

   void rtrim() {
      auto pos = size();
      for (auto c = this->rbegin(); c != this->rend(); c++) {
         pos--;
         if (  !isBlank(*c)) {
            *this = this->substr(0, ++pos);
            return;
         }
      }
    }
   auto& trim() {
      ltrim();
      rtrim();
      return *this;
   }
   unsigned int as_number()
   {
      int number = 0;
      auto number_str = this->asString();

      auto hex_pos = number_str.find("0x");
      if (hex_pos != std::string::npos)
      {
         number_str = number_str.substr(2 + hex_pos);
         auto err = std::from_chars(number_str.data(), number_str.data() + number_str.size(), number, 16);
         if (err.ec != std::errc()) {
            throw std::exception{  "Could not parse as numeric:" };
         }
      }
      else
      {
         auto err = std::from_chars(number_str.data(), number_str.data() + number_str.size(), number);
         if (err.ec != std::errc()) {
            throw std::exception{ "Could not parse as numeric:" };
         }
      }
      return number;
   }
   /*
   template<typename T>
   std::ostream& operator<< (T& out)
   {
      return out;
   }*/

   bool starts_with(std::wstring s) {
      return (this->substr(0, s.size()) == s);
   }
   auto md5hash()
   {

      DWORD dwStatus = 0;
      BOOL bResult = FALSE;
      HCRYPTPROV hProv = 0;
      HCRYPTHASH hHash = 0;
 
       DWORD cbRead = 0;
      BYTE rgbHash[MD5LEN];
      DWORD cbHash = 0;

      // Get handle to the crypto provider
      if (!CryptAcquireContext(&hProv,
         NULL,
         NULL,
         PROV_RSA_FULL,
         CRYPT_VERIFYCONTEXT))
      {
         dwStatus = GetLastError();
          throw std::exception("CryptAcquireContext failed");
 
      }

      if (!CryptCreateHash(hProv, CALG_MD5, 0, 0, &hHash))
      {
         dwStatus = GetLastError();
 
         CryptReleaseContext(hProv, 0);
         throw std::exception("CryptAcquireContext failed");

      }

      if (!CryptHashData(hHash, (const BYTE*)this->asString().c_str(), static_cast<DWORD>( this->asString().length() ), 0))
      {
         dwStatus = GetLastError();
         CryptReleaseContext(hProv, 0);
         CryptDestroyHash(hHash);
         throw std::exception("CryptHashData failed: ");

      }


      CHAR rgbDigits[] = "0123456789abcdef";
      cbHash = MD5LEN;
      char buf[ (MD5LEN *2)+ 1]{ 0x00 };
      if (CryptGetHashParam(hHash, HP_HASHVAL, rgbHash, &cbHash, 0))
      {
         for (DWORD i = 0; i < cbHash; i++)
         {
                     sprintf_s(&buf[i], MD5LEN,"%c%c", rgbDigits[rgbHash[i] >> 4], rgbDigits[rgbHash[i] & 0xf]);
         }

      }
      else
      {
         dwStatus = GetLastError();
         throw std::exception{ "CryptGetHashParam failed" };
      }

      CryptDestroyHash(hHash);
      CryptReleaseContext(hProv, 0);
  
      return unistr{ buf };
   }

   auto& findAndReplaceAll( unistr toSearch, unistr replaceStr ) 
   {
      size_t pos = this->find( toSearch );
      
      while( pos != std::wstring::npos ) 
      {
         this->replace( pos, toSearch.size(), replaceStr );
            pos = this->find( toSearch, pos + replaceStr.size() );
      }
      return *this;
   }
   
   template< typename ... Args >
   auto format( Args ... args )
   {
       std::wstring result;
       if ( ! this->empty() )
       {
           const size_t size = swprintf( nullptr, 0 , this->c_str(), args ... ); // Extra char for '\0'
           result.resize( size );
           if( swprintf( result.data(), result.size() + 1, this->c_str(), args ... ) == -1 )
           {
               throw std::system_error( std::error_code( errno, std::system_category() ) );
           }
       }
       return result;
   } 
   operator PUNICODE_STRING() { 
      return const_cast< PUNICODE_STRING >( asUNICODE_STRING() );
   }
  // friend unistr operator+ (unistr& me,const std::string& t) { return std::wstring(me)+ std::wstring{ t.begin(),t.end() }; }
   //friend std::string operator+ ( std::string t, NT::unistr& me ) { return  t + (me) ; }

   auto& uppercase() {
      std::transform(this->begin(), this->end(), this->begin(), ::toupper);
      return *this;
   }

   auto asHex()
   {
      std::wstringstream result;
      std::string u = this->asString();
      for (unsigned char c : u)
      {
         result  << std::hex << std::uppercase << static_cast<unsigned int>(c)  ;
      }
      return unistr{ result.str() };
   }
   template<typename T>
   std::vector<T> split(  T delimiter) {
      size_t pos_start = 0, pos_end, delim_len = delimiter.length();
      std::wstring token;
      std::vector<T> res;

      while ((pos_end = this->find(delimiter, pos_start)) != std::wstring::npos) {
         token = this->substr(pos_start, pos_end - pos_start);
         pos_start = pos_end + delim_len;
         res.push_back(token);
      }

      res.push_back(this->substr(pos_start));
      return res;
   }
   template<typename T>
     auto  before(  T  del) {
        auto pos = this->find(del);
        if (pos == std::wstring::npos) {
           pos = 0;
        }  else { 
            
        
           auto seperated = unistr{ this->substr(0, pos++) }.trim();
           *this = this->substr(pos+del.length()-1);
           trim();
           return  unistr{ seperated };
        }
        return  *this ;
     }
     template<typename T>
     auto  after(T  del) {
        auto pos = this->find(del);
        if (pos == std::wstring::npos) {
           return T{};
        }
        else {
           auto seperated = unistr{ this->substr(pos+del.length()) }.trim();
           *this = this->substr(0,pos  );
           trim();
           return  unistr{ seperated };
        }
        return  *this;
     }
 };


class file;

struct strpath : public unistr
{
   static auto expandEnvStrings( std::wstring unexpanded )
   {
      const DWORD cchNeeded = ExpandEnvironmentStringsW( unexpanded.data(), nullptr, 0 );
      THROW_LAST_ERROR_IF( 0 == cchNeeded );

      std::unique_ptr< wchar_t[] > cmdlineExpanded = std::make_unique< wchar_t[] >( cchNeeded );
      THROW_LAST_ERROR_IF( ExpandEnvironmentStringsW( unexpanded.data(), cmdlineExpanded.get(), cchNeeded ) == 0 );

      return std::wstring( cmdlineExpanded.get() );
   }


   template<typename T>
   strpath( T t ) :
      unistr{ expandEnvStrings( unistr {    t  }.asWideString() ) }
   {}

  template<typename T , typename = decltype( declval<T>().getFinalPath()) >
   strpath(T t) :
      unistr{ expandEnvStrings(unistr {    t.getFinalPath()  }) }
   {}
   void defineAsDosDevice( strpath dosDeviceName ) {
      THROW_LAST_ERROR_IF( ! DefineDosDevice( DDD_RAW_TARGET_PATH,(dosDeviceName).c_str(), ( *this ).c_str() ) );
      std::wcout << L"Defined: " + dosDeviceName + L"(" + dosDeviceName.asHex() + L") as dosdevice, targetting: " + *this << std::endl ;
   }
   void unDefineAsDosDevice() {
      THROW_LAST_ERROR_IF( ! DefineDosDevice( DDD_RAW_TARGET_PATH | DDD_REMOVE_DEFINITION, this->c_str() , nullptr ) );
      std::wcout << L"Undefined: " + *this + L" as dosdevice" << std::endl;
   }
   /*
   void mountOn( strpath mountLocation ) {
      THROW_LAST_ERROR_IF( ! SetVolumeMountPoint( ensureNT(*this).c_str(), mountLocation.c_str() ) );
      std::wcout << L"Mounted: "s + *this + L" on "s + mountLocation << std::endl;
   }*/
#pragma comment(lib, "mpr.lib")
#pragma comment(lib, "Netapi32.lib")
 
   void mapNetDrive(strpath newDrive,const wchar_t* szUserName,const wchar_t* szPassword) {

      NETRESOURCE nr;
  
      nr.dwType = RESOURCETYPE_ANY;
      nr.lpLocalName = const_cast<wchar_t*>(newDrive.c_str());
      nr.lpRemoteName = const_cast<wchar_t*>(this->c_str());
      nr.lpProvider = NULL;
   
      THROW_LAST_ERROR_IF(NO_ERROR != WNetAddConnection2(&nr, szPassword, szUserName, FALSE));
      std::wcout << L"mapped network drive: "s + *this + L" on "s + newDrive << std::endl;

   }
  
     friend strpath operator/ ( std::wstring w,   const strpath& me ) { 
       return   fs::path{ w.c_str()  }  / fs::path{ me.c_str() };
    }

    template<typename T, decltype(declval<T>().getFinalPath()) >
    friend strpath operator/ (const T w, const   strpath& me) {
        return   fs::path{ w.getFinalPath()  } / fs::path{ me.c_str() };
    }
    //    friend strpath operator+ ( strpath& me, std::wstring w ) { return NT::unistr( me ) + w; }
 
//   strpath operator+ ( std::wstring w ) { return this->c_str() + w;   } 

   operator fs::path() const { return   fs::path(  this->c_str() ); }
 
};

struct ntpath : public strpath 
{
   using strpath::strpath;

   unistr ensureNT(  unistr  asUni  )
   {
      if( asUni.length() == 0 || asUni.starts_with( L"\\" ) ) return asUni;

      return  L"\\??\\" + asUni;
   }

   template< typename T >
   ntpath( T t ) : strpath{ ensureNT(  std::forward< T >(t) ) } {}
};

struct regpath : public strpath
{
   using strpath::strpath;

   unistr ensureReg(unistr  asReg)
   {
      if (asReg.length() == 0 || asReg.starts_with(L"\\")) return asReg;

      return  L"\\Registry\\" + asReg;
   }
   template< typename T >
   regpath(T t) : strpath{  std::forward< T >(t)   } {}
};

namespace literalNS
{
    strpath operator "" _p( const char* unexpanded, std::size_t ){
      return strpath{ unexpanded };
   }
    unistr operator "" _u( const char* unexpanded, std::size_t ){
      return unistr{ unexpanded };
   }
    strpath operator "" _nt( const char* unexpanded, std::size_t ){
      return ntpath{ unexpanded };
   }
   strpath operator "" _reg(const char* unexpanded, std::size_t) {
      return regpath{ unexpanded };
   }
}

using namespace literalNS;