#pragma once

#include "../../pch.h" 
#include "misc.h"

struct MODERN_OPLOCK {
   REQUEST_OPLOCK_INPUT_BUFFER  g_inputBuffer;
   REQUEST_OPLOCK_OUTPUT_BUFFER g_outputBuffer;

   MODERN_OPLOCK( DWORD CACHE_LEVEL, DWORD INPUT_FLAG, DWORD OUTPUT_FLAG = 0 ) {
      g_inputBuffer.StructureVersion     = REQUEST_OPLOCK_CURRENT_VERSION;
      g_inputBuffer.StructureLength      = sizeof( g_inputBuffer );
      g_inputBuffer.RequestedOplockLevel = CACHE_LEVEL;
      g_inputBuffer.Flags                = INPUT_FLAG;

      g_outputBuffer.StructureVersion = REQUEST_OPLOCK_CURRENT_VERSION;
      g_outputBuffer.StructureLength  = sizeof( g_outputBuffer );
      g_outputBuffer.Flags            = OUTPUT_FLAG;
   }
};

struct OVERLAPPED_EVENT : public OVERLAPPED {
   OVERLAPPED_EVENT() { this->hEvent = CreateEvent( nullptr, FALSE, FALSE, nullptr ); }
   ~OVERLAPPED_EVENT() { if (this->hEvent != INVALID_HANDLE_VALUE) CloseHandle(  this->hEvent ); }
};
   
namespace details
{
   template<typename T>
   struct ack {
      T t;
      HANDLE h;
      OVERLAPPED_EVENT* o;
      bool done = false;
      ack(HANDLE h, OVERLAPPED_EVENT* o, T t) :h{ h }, o{ o }, t{ t }{}
      
      void doAck() 
      {
         if (done) return;

         done = true;

         MODERN_OPLOCK oplock_ack{
             0,
             REQUEST_OPLOCK_INPUT_FLAG_ACK,
             0
         };

         DeviceIoControl( 
            h,
            FSCTL_REQUEST_OPLOCK,
            (LPVOID)&oplock_ack.g_inputBuffer,
            sizeof(oplock_ack.g_inputBuffer),
            (LPVOID)&oplock_ack.g_outputBuffer,
            sizeof(oplock_ack.g_outputBuffer),
            nullptr,
            o
         );
      }
   };
   template<typename T>
   ack(HANDLE, OVERLAPPED_EVENT*, T) -> ack<T>;

   struct oplock 
   {

      template< typename T >
      oplock( T& handle,  std::function< bool(ack<T>) >  onbreak  )
      {
 
         MODERN_OPLOCK oplock{   OPLOCK_LEVEL_CACHE_WRITE | OPLOCK_LEVEL_CACHE_READ | OPLOCK_LEVEL_CACHE_HANDLE, 
                                 REQUEST_OPLOCK_INPUT_FLAG_REQUEST,
                                 0 
         };

         OVERLAPPED_EVENT overlapped{};
         bool loop = true;
         while(loop)
         {       
            auto bSuccess = DeviceIoControl( handle.getHandle(),
                                             FSCTL_REQUEST_OPLOCK,
                                             (LPVOID) &oplock.g_inputBuffer,
                                             sizeof( oplock.g_inputBuffer ),
                                             (LPVOID) &oplock.g_outputBuffer,
                                             sizeof( oplock.g_outputBuffer ),
                                             nullptr,
                                             &overlapped );
        
            DWORD dwBytes;
            if( !GetOverlappedResult( handle.getHandle(), &overlapped, &dwBytes, true ) )
               throw std::exception {   ": Oplock waiting failed" };
               
            ack a{ handle.getHandle(), &overlapped,handle };
            loop = onbreak(a);
            a.doAck();
         }  
      }
   };
}
 
using oplock = NT::misc::threaded< details::oplock  >;
template < typename T >
using ack = details::ack<T>;