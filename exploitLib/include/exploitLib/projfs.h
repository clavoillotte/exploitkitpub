#pragma once
#include <projectedfslib.h>
#include "exploitLib.h"
#include <winerror.h>
#include <map>
#include "../../pch.h" 

#define STATUS_CANNOT_DELETE             ((NTSTATUS)0xC0000121L)

#pragma comment(lib, "ProjectedFSLib.lib")
 
struct dirEntry : public PRJ_FILE_BASIC_INFO {
   std::wstring filename;
   template<typename ...Ts>
   dirEntry(std::wstring filename, Ts... ts) : filename{filename}, PRJ_FILE_BASIC_INFO{ std::forward<Ts>( ts )... }
   {}
 };

#define LOG_CALLBACK  if( CallbackData )  {  std::wcout                                                                                                                    <<   \
                                             x::unistr{ __func__ }.findAndReplaceAll("Callback_C",":").makelen(20)                                                         <<   \
                                             x::unistr{CallbackData->FilePathName }.makelen(40)                                                                            <<   \
                                             x::unistr{ CallbackData->TriggeringProcessImageFileName}.findAndReplaceAll(L"\\Device\\HarddiskVolume3",L"C:").makelen(53)  <<   \
                                             L"(" << CallbackData->TriggeringProcessId  << L")" << std::endl; };                         

using preFileOpenCallback  = std::function< void( const PRJ_CALLBACK_DATA* CallbackData ) >;
using dirListCallback      = std::function< void( const PRJ_CALLBACK_DATA* CallbackData, std::vector< dirEntry >& dirEntries ) >;
using fileReadCallback = std::function< void( std::wstring filename, std::vector<unsigned char>& data) >;

struct callbackcontainer
{
   preFileOpenCallback preFileOpen = []( const PRJ_CALLBACK_DATA* CallbackData) {};
   dirListCallback     dirListing  = []( const PRJ_CALLBACK_DATA* CallbackData, std::vector< dirEntry > & dirEntries) {};
   fileReadCallback    fileread    = []( std::wstring filename, std::vector<unsigned char>& data) {};
   
   PRJ_NAMESPACE_VIRTUALIZATION_CONTEXT _instanceHandle;
 
};

static std::map< std::wstring, std::vector< dirEntry >&  > enumsdone;


static HRESULT GetDirEnumCallback_C( const PRJ_CALLBACK_DATA* CallbackData, const GUID* EnumerationId, PCWSTR SearchExpression, PRJ_DIR_ENTRY_BUFFER_HANDLE DirEnryBufferHandle ) {
   LOG_CALLBACK;
   callbackcontainer* container = (callbackcontainer*)CallbackData->InstanceContext;

   if (enumsdone.contains(x::guid::guidwrapper(*EnumerationId)))
   {
      auto& dirEntries = enumsdone.at(x::guid::guidwrapper(*EnumerationId));

      if (dirEntries.size() == 0)
         container->dirListing(CallbackData, dirEntries);

      while (dirEntries.size() >= 1)
      {
         auto e = dirEntries.back();

         if(   PrjFileNameMatch(e.filename.c_str(), SearchExpression) && 
               PrjFillDirEntryBuffer(e.filename.c_str(), static_cast<PRJ_FILE_BASIC_INFO*>(&e), DirEnryBufferHandle) != S_OK 
           ) return S_OK;

         dirEntries.pop_back();
      }
      enumsdone.erase(x::guid::guidwrapper(*EnumerationId));
   }
   return S_OK;
};

static HRESULT EndDirEnumCallback_C(const PRJ_CALLBACK_DATA* CallbackData, const GUID* EnumerationId)
{
   LOG_CALLBACK;
    return S_OK;
};

static HRESULT GetPlaceholderInfoCallback_C(const PRJ_CALLBACK_DATA* CallbackData) {
   LOG_CALLBACK;
   callbackcontainer* container = (callbackcontainer*) CallbackData->InstanceContext;
   container->preFileOpen(CallbackData);
   return S_OK;
};

static HRESULT StartDirEnumCallback_C(const PRJ_CALLBACK_DATA* CallbackData, const GUID* EnumerationId) {
   LOG_CALLBACK;
   std::vector< dirEntry >* dirEntries = new std::vector< dirEntry > {};

   enumsdone.emplace(x::guid::guidwrapper(*EnumerationId), *dirEntries);

   return S_OK;
};


static HRESULT GetFileDataCallback_C(     const PRJ_CALLBACK_DATA* CallbackData, UINT64 ByteOffset, UINT32 Length) {
   LOG_CALLBACK;
   callbackcontainer* container = (callbackcontainer*)CallbackData->InstanceContext;

   std::vector<unsigned char> data;
   container->fileread(CallbackData->FilePathName, data);
 

    void* writeBuffer = PrjAllocateAlignedBuffer(CallbackData->NamespaceVirtualizationContext, 512 );

   int o = 0;

  do{
     memcpy_s(writeBuffer, 512, &data[o], 512);

      auto HR=PrjWriteFileData(container->_instanceHandle,
         &CallbackData->DataStreamId,
         writeBuffer,
         0,
         512
      );
      o = o + 512;
}while (o < data.size());

   PrjFreeAlignedBuffer(writeBuffer);
    return S_OK;
};

static HRESULT QueryFileName_C(const PRJ_CALLBACK_DATA* CallbackData) {
   LOG_CALLBACK;
   return S_OK;
};

static void CancelCommand_C(const PRJ_CALLBACK_DATA* CallbackData) {
   LOG_CALLBACK;
};


static HRESULT NotificationCallback_C(    const PRJ_CALLBACK_DATA*            CallbackData,
                                                BOOLEAN                       IsDirectory, 
                                                PRJ_NOTIFICATION              NotificationType, 
                                                PCWSTR                        DestinationFileName, 
                                                PRJ_NOTIFICATION_PARAMETERS*  NotificationParameters
                                     )
{
   LOG_CALLBACK;
 
   HRESULT hr;
   switch (NotificationType)
   {
      case PRJ_NOTIFICATION_FILE_OPENED:
         wprintf(L"\n ----- [%s] was opened\n", lstrlenW(CallbackData->FilePathName)==0 ? L"\\"  : CallbackData->FilePathName) ;
      break;
      case PRJ_NOTIFICATION_FILE_HANDLE_CLOSED_FILE_MODIFIED:
         wprintf(L"\n ----- [%s] was closed\n", lstrlenW(CallbackData->FilePathName) == 0 ? L"\\" : CallbackData->FilePathName);
      break;
      case PRJ_NOTIFICATION_FILE_OVERWRITTEN:
         wprintf(L"\n ----- [%s] was overwritten\n", CallbackData->FilePathName);
      break;
      case PRJ_NOTIFICATION_NEW_FILE_CREATED:
         wprintf(L"\n ----- [%s] was created\n", CallbackData->FilePathName);
      break;
      case PRJ_NOTIFICATION_FILE_RENAMED:
         wprintf(L"\n ----- [%s] -> [%s]\n", CallbackData->FilePathName, DestinationFileName);
      break;
      case PRJ_NOTIFICATION_FILE_HANDLE_CLOSED_FILE_DELETED:
         wprintf(L"\n ----- [%s] was deleted\n", CallbackData->FilePathName);
      break;
      case PRJ_NOTIFICATION_PRE_RENAME:
         hr = HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED);
         wprintf(L"\n ----- rename request for [%s] was rejected \n", CallbackData->FilePathName);
      break;
      case PRJ_NOTIFICATION_PRE_DELETE:
         hr = HRESULT_FROM_NT(STATUS_CANNOT_DELETE);
         wprintf(L"\n ----- delete request for [%s] was rejected \n", CallbackData->FilePathName);
      break;
      case PRJ_NOTIFICATION_FILE_PRE_CONVERT_TO_FULL:
         wprintf(L"\n ----- [%s] is converting to full \n", CallbackData->FilePathName);
      break;
      default:
         wprintf(L"%hs: Unexpected notification\n",    __FUNCTION__);
   }
   return S_OK;
};

struct  virtualRoot : public callbackcontainer
{
    const x::strpath folder;

   virtualRoot( x::strpath folder ) : folder{ folder }
   {
      auto pathHash = x::unistr{ folder }.md5hash();
 
      auto folderGuid = x::guid{ 
                                    x::unistr{ L"{%c%c%c%c%c%c%c%c-%c%c%c%c-%c%c%c%c-%c%c%c%c-%c%c%c%c%c%c%c%c%c%c%c%c}" }.format
                                    (
                                       'a', 'a', 'a' , 'a' ,
                                       pathHash.at(0),  pathHash.at(1), pathHash.at(2),  pathHash.at(4),  pathHash.at(5),  pathHash.at(6),  pathHash.at(7), 
                                       pathHash.at(8),  pathHash.at(9), pathHash.at(10), pathHash.at(11), pathHash.at(12), pathHash.at(13), pathHash.at(14), 
                                       pathHash.at(15), pathHash.at(16),
                                       'f', 'f', 'f', 'f', 'f', 'f', 'f', 'f','f','f','f','f','f'
                                    ).c_str()
                               };

      try { x::file{ folder ,FILE_WRITE_ATTRIBUTES ,FILE_OPEN_REPARSE_POINT }.delete_reparse_point( IO_REPARSE_TAG_PROJFS ); } catch (...) {}
      THROW_IF_FAILED( PrjMarkDirectoryAsPlaceholder( folder.c_str(), nullptr, nullptr, folderGuid ) );

      PRJ_STARTVIRTUALIZING_OPTIONS _options              = {};
      PRJ_NOTIFICATION_MAPPING notificationMappings[1]    = {};
      notificationMappings[0].NotificationRoot            = L"";
      notificationMappings[0].NotificationBitMask         = PRJ_NOTIFY_FILE_OPENED  | PRJ_NOTIFY_NEW_FILE_CREATED | PRJ_NOTIFY_FILE_OVERWRITTEN | PRJ_NOTIFY_PRE_DELETE	| PRJ_NOTIFY_PRE_RENAME |                                                                 PRJ_NOTIFY_PRE_SET_HARDLINK | PRJ_NOTIFY_FILE_RENAMED | PRJ_NOTIFY_HARDLINK_CREATED | PRJ_NOTIFY_FILE_HANDLE_CLOSED_NO_MODIFICATION |                                                                 PRJ_NOTIFY_FILE_HANDLE_CLOSED_FILE_MODIFIED | PRJ_NOTIFY_FILE_HANDLE_CLOSED_FILE_DELETED | PRJ_NOTIFY_FILE_PRE_CONVERT_TO_FULL;

      PRJ_STARTVIRTUALIZING_OPTIONS opts                  = {};
      opts.NotificationMappings                           = notificationMappings;
      opts.NotificationMappingsCount                      = 16;

      PRJ_CALLBACKS _callbacks                            = {};
      
      // Register the required C callbacks.
      _callbacks.StartDirectoryEnumerationCallback        = StartDirEnumCallback_C;
      _callbacks.EndDirectoryEnumerationCallback          = EndDirEnumCallback_C;
      _callbacks.GetDirectoryEnumerationCallback          = GetDirEnumCallback_C;
      _callbacks.GetPlaceholderInfoCallback               = GetPlaceholderInfoCallback_C;
      _callbacks.GetFileDataCallback                      = GetFileDataCallback_C;
      _callbacks.NotificationCallback                     = NotificationCallback_C;
      _callbacks.QueryFileNameCallback                    = QueryFileName_C;
      _callbacks.CancelCommandCallback                    = CancelCommand_C;

      THROW_IF_FAILED( PrjStartVirtualizing( folder.c_str(), &_callbacks,this  , nullptr, &_instanceHandle ) );
   }

   ~virtualRoot() 
   {
      try { PrjStopVirtualizing( _instanceHandle ); } catch (...) {}
      try {  x::file{ folder , FILE_WRITE_ATTRIBUTES, FILE_OPEN_REPARSE_POINT }.delete_reparse_point( IO_REPARSE_TAG_PROJFS ); } catch (...) {}
   }
    
   void makefile(x::strpath name, bool isdir = false)
   {
      PRJ_PLACEHOLDER_INFO placeholderInfo      = {};
      placeholderInfo.FileBasicInfo.IsDirectory = isdir;
      placeholderInfo.FileBasicInfo.FileSize    = 40;
      THROW_IF_FAILED( PrjWritePlaceholderInfo( _instanceHandle, name, &placeholderInfo, sizeof(placeholderInfo) - 1 ) );
   }

   void makeSymlink( x::strpath name, x::strpath destination, bool dir = false )
   {
      PRJ_PLACEHOLDER_INFO placeholderInfo      = {};
      placeholderInfo.FileBasicInfo.IsDirectory = dir;
      placeholderInfo.FileBasicInfo.FileSize    = 0;

      PRJ_EXTENDED_INFO ex{};
      ex.InfoType                               = PRJ_EXT_INFO_TYPE::PRJ_EXT_INFO_TYPE_SYMLINK;
      ex.Symlink.TargetName                     = destination;
      ex.NextInfoOffset                         = 0;
      
      THROW_IF_FAILED( PrjWritePlaceholderInfo2( _instanceHandle, name, &placeholderInfo, sizeof(placeholderInfo)-1, &ex ) );
   }

};