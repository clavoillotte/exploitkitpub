#pragma once

#include "../../../pch.h"  
 
#include "../str.h"
#include "../misc.h"

#include "wil/result.h"
 
#pragma comment(lib, "cimfs.lib")

#define MOUNTMGRCONTROLTYPE  ((ULONG) 'm')
#define IOCTL_MOUNTMGR_CREATE_POINT                 CTL_CODE(MOUNTMGRCONTROLTYPE, 0, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)
#define IOCTL_MOUNTMGR_VOLUME_ARRIVAL_NOTIFICATION  CTL_CODE(MOUNTMGRCONTROLTYPE, 11, METHOD_BUFFERED, FILE_READ_ACCESS)

typedef struct _MOUNTMGR_CREATE_POINT_INPUT {
    USHORT  SymbolicLinkNameOffset;
    USHORT  SymbolicLinkNameLength;
    USHORT  DeviceNameOffset;
    USHORT  DeviceNameLength;
} MOUNTMGR_CREATE_POINT_INPUT, * PMOUNTMGR_CREATE_POINT_INPUT;


typedef struct _MOUNTMGR_TARGET_NAME {
   USHORT  DeviceNameLength;
   WCHAR   DeviceName[1];
} MOUNTMGR_TARGET_NAME, * PMOUNTMGR_TARGET_NAME;

#define CIMFS_MOUNT 0x220004
#define IOCTL_PLUGIN_DEVICE_RETURN_WAITHANDLE		CTL_CODE(FILE_DEVICE_BUS_EXTENDER,0x012,METHOD_BUFFERED,FILE_READ_DATA|FILE_WRITE_DATA)

#define MAX_STR_SIZE 512
struct VirtualCDMountParams
{
   wchar_t wszFilePath[MAX_STR_SIZE];
   unsigned StructureVersion;
   bool DisableAutorun;
   char SuggestedDriveLetter;
   bool KeepAfterRestart;
   unsigned short MMCProfile;

   enum { CurrentVersion = 4 };
};

 auto  testmountpoint()
{
    x::file cd{ "\\device\\WinisoCDBus"_p,FILE_GENERIC_READ | FILE_GENERIC_WRITE,0,FILE_OPEN };
    char obuf[80]{ 0x00 };
    DWORD r = 0;

    //impersonatePilotsHubApp();
    VirtualCDMountParams wp{ L"\\??\\c:\\temp\\cd.iso",2,false,'e',true,0x0008 };


    wchar_t drive[]{ L"\\??\\Globalroot\\global??\\C:\\Users\\jonas\\AppData\\LocalLow\\burn.iso" };

    DeviceIoControl(cd.getHandle(), IOCTL_PLUGIN_DEVICE_RETURN_WAITHANDLE, &wp, sizeof(wp), obuf, 80, &r, nullptr);
    return 0;
 
     auto  hMountMgr = x::file{ "\\DEVICE\\MountPointManager\\\\"_p, MAXIMUM_ALLOWED };
      
  /* std::wstring symlink{ L"\\??\\q:" };
   std::wstring device{ L"\\Device\\q:" };
    
 
     std::vector<uint8_t> buf(sizeof(MOUNTMGR_CREATE_POINT_INPUT) + ((symlink.length() + device.length()) * sizeof(WCHAR)));
    auto mcpi = reinterpret_cast<MOUNTMGR_CREATE_POINT_INPUT*>(buf.data());

    mcpi->SymbolicLinkNameOffset = sizeof(MOUNTMGR_CREATE_POINT_INPUT);
    mcpi->SymbolicLinkNameLength = (USHORT)(symlink.length() * sizeof(WCHAR));
    mcpi->DeviceNameOffset = (USHORT)(mcpi->SymbolicLinkNameOffset + mcpi->SymbolicLinkNameLength);
    mcpi->DeviceNameLength = (USHORT)(device.length() * sizeof(WCHAR));

    memcpy((uint8_t*)mcpi + mcpi->SymbolicLinkNameOffset, symlink.data(), symlink.length() * sizeof(WCHAR));
    memcpy((uint8_t*)mcpi + mcpi->DeviceNameOffset, device.data(), device.length() * sizeof(WCHAR));
*/
     std::wstring target{ L"\\\\?\\C:" };
     std::vector<uint8_t> buf(sizeof(MOUNTMGR_TARGET_NAME) + ((target.length()  ) * sizeof(WCHAR)));
     auto mcpi = reinterpret_cast<MOUNTMGR_TARGET_NAME*>(buf.data());
     mcpi->DeviceNameLength = target.length();
     memcpy((uint8_t*)mcpi + mcpi->DeviceName[0], target.data(), target.length() * sizeof(WCHAR));

 //   DWORD cb;
    IO_STATUS_BLOCK io_status{ 0x00 };
    THROW_NTSTATUS(NtDeviceIoControlFile(hMountMgr, nullptr, nullptr, nullptr, &io_status, IOCTL_MOUNTMGR_VOLUME_ARRIVAL_NOTIFICATION, buf.data(), (ULONG)buf.size(), nullptr, 0));


  // THROW_NTSTATUS( NtDeviceIoControlFile(hMountMgr, nullptr, nullptr, nullptr, &io_status, IOCTL_MOUNTMGR_CREATE_POINT,      buf.data(), (ULONG)buf.size(), nullptr, 0));
 

   // THROW_IF_WIN32_BOOL_FALSE( DeviceIoControl(hMountMgr, IOCTL_MOUNTMGR_CREATE_POINT,(LPVOID)mcpi, (ULONG)buf.size(), nullptr, 0, &cb, nullptr) );
   
    std::wcout << (   L"mount point success:"s + L"\n"s) << std::endl;
    return 0;
}