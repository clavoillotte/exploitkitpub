   #pragma once
#include <winioctl.h>
#include "../../pch.h"  
#include "wil/result.h"
#include "NTcore.h"
#include "str.h"  
#include "misc.h"
#include "misc.h"



static constexpr auto lookup_table = ([]()
   {
      std::array<uint8_t, 0x100> tbl = { 0 };
      tbl[0] = 0x00;
      for (int i = 0; i <= 0xFF; i++)
      {
         if ('0' <= i && i <= '9')      tbl[i] = i - '0';
         else if ('a' <= i && i <= 'f') tbl[i] = i - 'a' + 0xA;
         else if ('A' <= i && i <= 'F') tbl[i] = i - 'A' + 0xA;
         else                             tbl[i] = 0;
      }
      return tbl;
   }());



static const inline  BYTE CharToValue[0x80] =
{
   //   00    01    02    03    04    05    06    07    08    09    0A    0B    0C    0D    0E    0F
       0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
       0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
       0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
       0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
       0xFF, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
       0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
       0xFF, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
       0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
};

constexpr uint8_t to_byte(const unsigned char* str)
{
   return (lookup_table[str[0]] << 4) | (lookup_table[str[1]]);
}

std::vector<uint8_t> to_byte_array(const unsigned char* str, unsigned int len)
{
   std::vector<uint8_t> result = {};
   result.reserve(len / 2);
   for (unsigned int it = 0; it < len; it += 2)
   {
      auto u = std::stoi(std::string{ (char*)(str + it),2 }, 0, 16);
      result.push_back(u);

   }
   return result;
}



template<class T>
class typed_buffer_ptr
{
   std::unique_ptr< char[] > buffer_;
   size_t size_;

public:
   typed_buffer_ptr() {}
   explicit typed_buffer_ptr(size_t size) { reset(size); }
   explicit typed_buffer_ptr(size_t size, void* in) { reset(size); memcpy_s(buffer_.get(), size, in, size); }

   void reset(size_t size) {
      buffer_.reset(new char[size]);
      memset(buffer_.get(), 0, size);
      size_ = size;
   }

   void resize(size_t size) {
      std::unique_ptr<char[]> tmp(new char[size]);
      memcpy(tmp.get(), buffer_.get(), min(size, size_));
      buffer_ = std::move(tmp);
   }

   operator T* () { return reinterpret_cast<T*>(buffer_.get()); }

   operator const T* () const { return cget(); }

   T* operator->() const { return reinterpret_cast<T*>(buffer_.get()); }

   const T* cget() const { return reinterpret_cast<const T*>(buffer_.get()); }

   typed_buffer_ptr(const typed_buffer_ptr<T>& other) = delete;
   typed_buffer_ptr& operator=(const typed_buffer_ptr<T>& other) = delete;

   typed_buffer_ptr(typed_buffer_ptr<T>&& other) {
      buffer_ = std::move(other.buffer_);
      size_ = other.size_;
      other.size_ = 0;
   }

   typed_buffer_ptr& operator=(typed_buffer_ptr<T>&& other) {
      if (this != &other)
      {
         buffer_ = std::move(other.buffer_);
         size_ = other.size_;
         other.size_ = 0;
      }
   }
   size_t size() const { return size_; }
};


#define SYMLINK_FLAG_RELATIVE   0x00000001   // If set then this is a relative symlink.
#define SYMLINK_DIRECTORY       0x80000000   // If set then this is a directory symlink. This is not persisted on disk and is programmatically set by file system.
#define SYMLINK_FILE            0x40000000   // If set then this is a file symlink. This is not persisted on disk and is programmatically set by file system.

#define REPARSE_DATA_EX_FLAG_GIVEN_TAG_OR_NONE              (0x00000001)


#define REPARSE_GUID_DATA_BUFFER_EX_HEADER_SIZE \
    UFIELD_OFFSET(REPARSE_DATA_BUFFER_EX, ReparseGuidDataBuffer.GenericReparseBuffer)

#define REPARSE_DATA_BUFFER_EX_HEADER_SIZE \
    UFIELD_OFFSET(REPARSE_DATA_BUFFER_EX, ReparseDataBuffer.GenericReparseBuffer)

// The reparse tags are a ULONG. The 32 bits are laid out as follows:
//
//   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 //  +-+-+-+-+-----------------------+-------------------------------+
//  |M|R|N|D|     Reserved bits     |       Reparse Tag Value       |
//  +-+-+-+-+-----------------------+-------------------------------+0

//
// M is the Microsoft bit. When set to 1, it denotes a tag owned by Microsoft.
//   All ISVs must use a tag with a 0 in this position.
//   Note: If a Microsoft tag is used by non-Microsoft software, the
//   behavior is not defined.
//
// R is reserved.  Must be zero for non-Microsoft tags.
//
// N is name surrogate. When set to 1, the file represents another named
//   entity in the system.
//
// D is the directory bit. When set to 1, indicates that any directory
//   with this reparse tag can have children. Has no special meaning when used
//   on a non-directory file. Not compatible with the name surrogate bit.
//
// The M and N bits are OR-able.
// The following macros check for the M and N bit values:
//


typedef struct _REPARSE_DATA_BUFFER
{
   ULONG  ReparseTag;                          // Reparse tag type
   USHORT ReparseDataLength;                   // Length of the reparse data
   USHORT Reserved;                            // Used internally by NTFS to store remaining length

   union
   {
      // Structure for IO_REPARSE_TAG_SYMLINK
      // Handled by nt!IoCompleteRequest
      struct
      {
         USHORT SubstituteNameOffset;
         USHORT SubstituteNameLength;
         USHORT PrintNameOffset;
         USHORT PrintNameLength;
         ULONG Flags;
         WCHAR PathBuffer[1];
      } SymbolicLinkReparseBuffer;

      // Structure for IO_REPARSE_TAG_MOUNT_POINT
      // Handled by nt!IoCompleteRequest
      struct
      {
         USHORT SubstituteNameOffset;
         USHORT SubstituteNameLength;
         USHORT PrintNameOffset;
         USHORT PrintNameLength;
         WCHAR PathBuffer[1];
      } MountPointReparseBuffer;

      // Structure for IO_REPARSE_TAG_WIM
      // Handled by wimmount!FPOpenReparseTarget->wimserv.dll (wimsrv!ImageExtract)
      struct
      {
         GUID ImageGuid;                     // GUID of the mounted VIM image
         BYTE ImagePathHash[0x14];           // Hash of the path to the file within the image
      } WimImageReparseBuffer;

      // Structure for IO_REPARSE_TAG_WOF
      // Handled by FSCTL_GET_EXTERNAL_BACKING, FSCTL_SET_EXTERNAL_BACKING in NTFS (Windows 10+)
      struct
      {
         //-- WOF_EXTERNAL_INFO --------------------
         ULONG Wof_Version;                  // Should be 1 (WOF_CURRENT_VERSION)
         ULONG Wof_Provider;                 // Should be 2 (WOF_PROVIDER_FILE)

         //-- FILE_PROVIDER_EXTERNAL_INFO_V1 --------------------
         ULONG FileInfo_Version;             // Should be 1 (FILE_PROVIDER_CURRENT_VERSION)
         ULONG FileInfo_Algorithm;           // Usually 0 (FILE_PROVIDER_COMPRESSION_XPRESS4K)
      } WofReparseBuffer;

      // Structure for IO_REPARSE_TAG_APPEXECLINK
      struct
      {
         ULONG StringCount;                  // 
         
          WCHAR StringList[1];                // Multistring (strings separated by '\0', terminated by '\0\0')
      } AppExecLinkReparseBuffer;

      // Structure for IO_REPARSE_TAG_WCI (0x80000018)
      struct
      {
         ULONG Version;                      // Expected to be 1 by wcifs.sys
         ULONG Reserved;
         GUID  LookupGuid;                   // GUID used for lookup in wcifs!WcLookupLayer
         USHORT WciNameLength;               // Length of the WCI subname, in bytes
         WCHAR WciName[1];                   // The WCI subname (not zero terminated)
      } WcifsReparseBuffer;

      // Handled by cldflt.sys!HsmpRpReadBuffer
      struct
      {
         USHORT Flags;                       // Flags (0x8000 = not compressed)
         USHORT Length;                      // Length of the data (uncompressed)
         BYTE RawData[1];                    // To be RtlDecompressBuffer-ed
      } HsmReparseBufferRaw;

      // Dummy structure
      struct
      {
         UCHAR  DataBuffer[1];
      } GenericReparseBuffer;
   } DUMMYUNIONNAME;
} REPARSE_DATA_BUFFER, * PREPARSE_DATA_BUFFER;

#define REPARSE_DATA_BUFFER_HEADER_LENGTH FIELD_OFFSET( REPARSE_DATA_BUFFER, GenericReparseBuffer.DataBuffer )


typedef struct _REPARSE_DATA_BUFFER_EX {

   ULONG Flags;

   //
   //  This is the existing reparse tag on the file if any,  if the
   //  caller wants to replace the reparse tag too.
   //
   //    - To set the reparse data  along with the reparse tag that
   //      could be different,  pass the current reparse tag of the
   //      file.
   //
   //    - To update the reparse data while having the same reparse
   //      tag,  the caller should give the existing reparse tag in
   //      this ExistingReparseTag field.
   //
   //    - To set the reparse tag along with reparse data on a file
   //      that doesn't have a reparse tag yet, set this to zero.
   //
   //  If the ExistingReparseTag  does not match the reparse tag on
   //  the file,  the FSCTL_SET_REPARSE_POINT_EX  would  fail  with
   //  STATUS_IO_REPARSE_TAG_MISMATCH. NOTE: If a file doesn't have
   //  a reparse tag, ExistingReparseTag should be 0.
   //

   ULONG ExistingReparseTag;

   //
   //  For non-Microsoft reparse tags, this is the existing reparse
   //  guid on the file if any,  if the caller wants to replace the
   //  reparse tag and / or guid along with the data.
   //
   //  If ExistingReparseTag is 0, the file is not expected to have
   //  any reparse tags, so ExistingReparseGuid is ignored. And for
   //  non-Microsoft tags ExistingReparseGuid should match the guid
   //  in the file if ExistingReparseTag is non zero.
   //

   GUID ExistingReparseGuid;

   //
   //  Reserved
   //

   ULONGLONG Reserved;

   //
   //  Reparse data to set
   //

   union {

      REPARSE_DATA_BUFFER ReparseDataBuffer;
      REPARSE_GUID_DATA_BUFFER ReparseGuidDataBuffer;

   } DUMMYUNIONNAME;

} REPARSE_DATA_BUFFER_EX, * PREPARSE_DATA_BUFFER_EX;

struct WcifsReparseBuffer
{
   ULONG Version;                      // Expected to be 1 by wcifs.sys
   ULONG Reserved;
   GUID  LookupGuid;                   // GUID used for lookup in wcifs!WcLookupLayer
   USHORT WciNameLength;               // Length of the WCI subname, in bytes
   WCHAR WciName[1];                   // The WCI subname (not zero terminated)
};

struct SymbolicLinkReparseBuffer
{
   USHORT SubstituteNameOffset;
   USHORT SubstituteNameLength;
   USHORT PrintNameOffset;
   USHORT PrintNameLength;
   ULONG Flags;
   WCHAR PathBuffer[1];
};
namespace reparsePoint
{

   void printSymlink(SymbolicLinkReparseBuffer* s)  
   {
   std::wcout << L"SubstituteOffset:\t" << std::to_wstring(s->SubstituteNameOffset) << std::endl;
   std::wcout << L"SubstituteLen:\t" << std::to_wstring(s->SubstituteNameLength) << std::endl;
   std::wcout <<
      L"Substite name:\t" <<
      std::wstring{ s->PathBuffer + s->SubstituteNameOffset  ,static_cast<ULONG>(s->SubstituteNameLength / 2) } <<
      std::endl;

   std::wcout << L"PrintOffset:\t" << std::to_wstring(s->PrintNameOffset) << std::endl;
   std::wcout << L"PrintLen:\t" << std::to_wstring(s->PrintNameLength) << std::endl;
  
   std::wcout << L"Print name:\t" <<
      std::wstring{
         s->PathBuffer + static_cast<ULONG>(s->PrintNameOffset / 2),
         static_cast<ULONG>(s->PrintNameLength / 2)
      } <<  std::endl;

   std::wcout << L"Flags:\t\t" <<  unistr{ s->Flags } << std::endl;
   }

   void printWCI(WcifsReparseBuffer* s)  
   {
   std::wcout << L"Guid:\t\t" << NT::misc::guidwrapper(s->LookupGuid) << std::endl;
   std::wcout << L"Reserved:\t" << std::to_wstring(s->Reserved) << std::endl;
   std::wcout << L"WciNameLength:\t" << std::to_wstring(s->WciNameLength) << std::endl;

   std::wcout << 
      L"Wciname:\t" <<
      std::wstring{ s->WciName    ,static_cast<ULONG>(s->WciNameLength / 2) } <<
      std::endl;
   std::wcout << L"Version:\t" << std::to_wstring(s->Version) << std::endl;
   }

   void  doPrintReparsePoint( typed_buffer_ptr< REPARSE_DATA_BUFFER > REPARSEINFO )  
   {
      std::wcout << L"ReparseTag:\t(0x" <<  unistr{ REPARSEINFO->ReparseTag } << L") - \t" << std::endl;
      std::wcout << L"ReparseLen:\t" << std::to_wstring(REPARSEINFO->ReparseDataLength) << std::endl;

      switch (REPARSEINFO->ReparseTag)
      {
      case IO_REPARSE_TAG_SYMLINK:
         printSymlink((SymbolicLinkReparseBuffer*)&REPARSEINFO->SymbolicLinkReparseBuffer);
         break;
      case IO_REPARSE_TAG_WCI:
      case IO_REPARSE_TAG_WCI_1:
         printWCI((WcifsReparseBuffer*)&REPARSEINFO->WcifsReparseBuffer);
         break;
      default:
         std::wcout << L"Unknown" << std::endl;
      }
      auto stream = std::string{ (char*)REPARSEINFO.cget() , ((ULONG)REPARSE_DATA_BUFFER_HEADER_LENGTH + REPARSEINFO->ReparseDataLength) };

      std::wstringstream result;
      for (unsigned char c : stream)
      {
         result << std::hex << std::setw(2) << std::setfill(L'0') << std::uppercase << static_cast<unsigned int>(c);
      }

      std::wcout << result.str() << std::endl;
      }

      template< auto logger = &std::wcout >
      typed_buffer_ptr< REPARSE_DATA_BUFFER > getReparsePoint( HANDLE h )  
      {
      typed_buffer_ptr< REPARSE_DATA_BUFFER > REPARSEINFO(MAXIMUM_REPARSE_DATA_BUFFER_SIZE + REPARSE_DATA_BUFFER_HEADER_LENGTH);

      DWORD cb;
      THROW_IF_WIN32_BOOL_FALSE(
         DeviceIoControl( h, FSCTL_GET_REPARSE_POINT, 0, 0, REPARSEINFO,static_cast<DWORD>( REPARSEINFO.size() ), &cb, 0)
      );

      return REPARSEINFO;
   }


   void doPrintReparsePoint( HANDLE h )
   {
      doPrintReparsePoint( getReparsePoint(h) );
   }


   typed_buffer_ptr< REPARSE_DATA_BUFFER > getSymlinkReparse( ntpath target)  
   {

      USHORT targetSize = static_cast<USHORT>( (target.size() * 2) )  ;

      typed_buffer_ptr< REPARSE_DATA_BUFFER > REPARSEINFO(REPARSE_DATA_BUFFER_HEADER_LENGTH + targetSize + 12);

      REPARSEINFO->ReparseTag = IO_REPARSE_TAG_SYMLINK;
      REPARSEINFO->ReparseDataLength = targetSize + 12;
      REPARSEINFO->Reserved = 0;

      REPARSEINFO->SymbolicLinkReparseBuffer.SubstituteNameOffset = 0;
      REPARSEINFO->SymbolicLinkReparseBuffer.SubstituteNameLength = targetSize;
      memcpy(REPARSEINFO->SymbolicLinkReparseBuffer.PathBuffer,
         target.c_str(),
         targetSize
      );

      REPARSEINFO->SymbolicLinkReparseBuffer.PrintNameOffset = 8;
      REPARSEINFO->SymbolicLinkReparseBuffer.PrintNameLength = targetSize - 8;
      REPARSEINFO->SymbolicLinkReparseBuffer.Flags = 0;
      return REPARSEINFO;
   }

   template< auto logger = &std::wcout >
   void changeReparsePoint(HANDLE h, ntpath target, ULONG existingReparseTag = 0)  
   {
      std::wstring NTtarget = target;
      auto targetSize = NTtarget.size() * 2;

      auto REPARSEINFO = getSymlinkReparse(target);

      typed_buffer_ptr< REPARSE_DATA_BUFFER_EX > REPARSEINFOEX(sizeof(REPARSE_DATA_BUFFER_EX) + REPARSEINFO.size() - 48);

      REPARSEINFOEX->Flags = REPARSE_DATA_EX_FLAG_GIVEN_TAG_OR_NONE;
      REPARSEINFOEX->ExistingReparseTag = 0;
      REPARSEINFOEX->Reserved = 0;

      memcpy(&REPARSEINFOEX->ReparseDataBuffer, REPARSEINFO, REPARSEINFO.size());

      DWORD cb;
      THROW_IF_WIN32_BOOL_FALSE(
         DeviceIoControl( h, FSCTL_SET_REPARSE_POINT_EX, REPARSEINFOEX,static_cast<DWORD>( REPARSEINFOEX.size() ), nullptr, 0, &cb, nullptr)
      );
   }


   void setReparsePoint(HANDLE h, unistr reparsePoint )
   {
      auto s = reparsePoint.asString();
      auto result = to_byte_array((const unsigned char*)s.c_str(), static_cast<unsigned int>( reparsePoint.length() ) );

      typed_buffer_ptr< REPARSE_DATA_BUFFER >   REPARSEINFO{ result.size(), &result[0] };
    
      DWORD   cb;
      THROW_IF_WIN32_BOOL_FALSE(
         DeviceIoControl( h, FSCTL_SET_REPARSE_POINT, (LPVOID)&result[0], static_cast<DWORD>( result.size() ), nullptr, 0, &cb, nullptr)
      );

   }

   void delete_reparse_point( HANDLE h, DWORD tag = IO_REPARSE_TAG_SYMLINK)   
   {
      typed_buffer_ptr< REPARSE_DATA_BUFFER > REPARSEINFO( REPARSE_DATA_BUFFER_HEADER_LENGTH );
      REPARSEINFO->ReparseDataLength = 0;
      REPARSEINFO->ReparseTag = tag;

      DWORD cb;
      THROW_IF_WIN32_BOOL_FALSE(
         DeviceIoControl( h, FSCTL_DELETE_REPARSE_POINT, REPARSEINFO, static_cast<DWORD>( REPARSEINFO.size() ), nullptr, 0, &cb, nullptr)
      );

   }

   void makeSymlink( HANDLE h, ntpath target )
   {
      auto REPARSEINFO = getSymlinkReparse(target);

      DWORD   cb;
      THROW_IF_WIN32_BOOL_FALSE(
         DeviceIoControl( h, FSCTL_SET_REPARSE_POINT, REPARSEINFO, static_cast<DWORD>(REPARSEINFO.size()), nullptr, 0, &cb, nullptr)
      );

   }

   void makeJunction( const HANDLE h, ntpath target )
   {
      DWORD   cb;
      std::wstring NTtarget = (target);

      const size_t target_byte_size = NTtarget.size() * 2;
      const size_t printname_byte_size = NTtarget.size() * 2;
      const size_t path_buffer_size = target_byte_size + printname_byte_size + 8 + 4;
      const size_t total_size = path_buffer_size + REPARSE_DATA_BUFFER_HEADER_LENGTH;

      typed_buffer_ptr< REPARSE_DATA_BUFFER > REPARSEINFO(total_size);

      REPARSEINFO->ReparseTag = IO_REPARSE_TAG_MOUNT_POINT;
      REPARSEINFO->ReparseDataLength = static_cast<USHORT>(path_buffer_size);
      REPARSEINFO->Reserved = 0;

      REPARSEINFO->MountPointReparseBuffer.SubstituteNameOffset = 0;
      REPARSEINFO->MountPointReparseBuffer.SubstituteNameLength = static_cast<USHORT>(target_byte_size);
      memcpy(REPARSEINFO->MountPointReparseBuffer.PathBuffer, NTtarget.c_str(), target_byte_size + 2);

      REPARSEINFO->MountPointReparseBuffer.PrintNameOffset = static_cast<USHORT>(target_byte_size + 2);
      REPARSEINFO->MountPointReparseBuffer.PrintNameLength = static_cast<USHORT>(printname_byte_size);
      memcpy(REPARSEINFO->MountPointReparseBuffer.PathBuffer + NTtarget.size() + 1, NTtarget.c_str(), printname_byte_size + 2);

      THROW_IF_WIN32_BOOL_FALSE(
         DeviceIoControl( h, FSCTL_SET_REPARSE_POINT, REPARSEINFO, static_cast<DWORD>(REPARSEINFO.size()), nullptr, 0, &cb, nullptr)
      );

   }

   void makeappexec( HANDLE h, std::wstring appPackageId, std::wstring AppUserModelID, std::wstring targetPath)
   {
      const size_t appexec_size =   ((appPackageId.size() + 1) * 2) +
                                    ((AppUserModelID.size() + 1) * 2) +
                                    ((targetPath.size() + 1) * 2) + 4;

      const size_t total_size = appexec_size + REPARSE_DATA_BUFFER_HEADER_LENGTH;

      typed_buffer_ptr< REPARSE_DATA_BUFFER > REPARSEINFO(total_size);

      REPARSEINFO->ReparseTag = IO_REPARSE_TAG_APPEXECLINK;
      REPARSEINFO->ReparseDataLength = static_cast<USHORT>(appexec_size);
      REPARSEINFO->Reserved = 0;

      REPARSEINFO->AppExecLinkReparseBuffer.StringCount = static_cast<USHORT>(3);
      auto all = appPackageId + L"\xFF" + AppUserModelID + L"\xFF" + targetPath + L"\xFF";

      for (auto& c : all)
      {
         if (c == L'\xFF') c = L'\x00';
      }
      memcpy(&REPARSEINFO->AppExecLinkReparseBuffer.StringList[0], all.c_str(), static_cast<DWORD>(all.size() * 2));

      DWORD   cb;
      THROW_IF_WIN32_BOOL_FALSE(
         DeviceIoControl( h, FSCTL_SET_REPARSE_POINT, REPARSEINFO, static_cast<DWORD>( REPARSEINFO.size() ), nullptr, 0, &cb, nullptr)
      );

   }

}
